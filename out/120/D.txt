島を頂点、橋を辺としたグラフを考えます。グラフから辺を削除していくのは難しいことが多いので、逆に
辺が 1 つもない状態から追加していくことを考えます。すなわち、後ろから答えを求めて配列に保存し、逆順
に出力します。

i 番目に出力すべき答えを ans(i) とします。辺を追加していくことを考えると、初めは全ての辺がない
ので、

ans(M ) =

N (N − 1)
2

です。さらに、各 i (1 ≤ i ≤ M − 1) について、i + 1 番目の辺 ei+1 = (ai+1 , bi+1 ) によって

1. 元々頂点 ai+1 , bi+1 が連結でなかった (互いに行き来可能でなかった) 場合
辺 e を加える前のグラフにおいて、頂点 ai+1 を含む連結成分の大きさを N1 、頂点 bi+1 を含む連結成
分の大きさを N2 とすると、

ans(i) = ans(i + 1) − N1 × N2

です。

2. 元々連結だった場合
不便さに変化はなく、ans(i) = ans(i + 1) です。
しかしこれを愚直に実装すると O(M (N + M )) かかってしまい、間に合いません。ボトルネックになってい
るところは、N1 , N2 を求める部分です。これは、以下の操作が行える、Union-Find と呼ばれるデータ構造を
用いることで効率よく求めることができます。

unite(u, v): 頂点 u が属するグループと頂点 v が属するグループを併合し、同じグループにする
(O(α(n)))
find(v): 頂点 v が属するグループ番号を得る (O(α(n)))
size(v): 頂点 v が属するグループと同じグループに属する頂点数を得る (O(1))
ここで、n は管理する頂点数、α はアッカーマン関数の逆関数ですが、O(α(n)) は O(1) とほとんど変わりま
せん。したがって、全体の計算量は O(M α(N )) となり十分間に合います。

4


