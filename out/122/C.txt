文字列 S の長さ N と問いの数 Q さえ小さければ、この問題は前問と同等の「書かれた通りに実装する」
問題になります。しかし、実際には N も Q も最大で 10 万と大きく、「書かれた通り」の実装を行うと最大
で延べ 100 億文字を走査することになります。これは、C++ のような高速な言語でも 2 秒で処理できる量
ではありません。処理を高速化する何らかの工夫が必要です。
範囲内の部分文字列 AC を数えよと問われていますが、その代わりに「右隣が C であるような A」を数えた
方が単純です。文字列中のこのような A を a に置き換えると、問 i は「li 文字目から ri − 1 文字目までの a
を数えよ」となります (右端が 1 左に動いたことに注意してください。ri 文字目が a であってもその右隣の

C が範囲からはみ出てしまうためです)。
ここで、ti =「S の 1 文字目から i 文字目までに出現する a の数」として数列 t = {t0 , t1 , . . . , tN } を考え
ると、問 i の答えは tri −1 − tli −1 として求められます。この数列 t を問いの処理を始める前に構築しておい
て使い回せば、入力サイズの線形時間ですべての問いを処理できます。

1

N, Q = map(int, input().split())

2

S = input()

3

t = [0] * (N + 1)

4

for i in range(N):

5
6

t[i + 1] = t[i] + (1 if S[i : i + 2] == 'AC' else 0)
for i in range(Q):

7

l, r = map(int, input().split())

8

print(t[r-1] - t[l-1])

3

