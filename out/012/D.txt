1. 問題概要
2. アルゴリズム

2023/1/20

©AtCoder Inc. All rights reserved.

19


• バスの路線図が与えられる
• 一番移動に時間がかかってしまうバス停のペアの、
移動にかかる時間を出力しなさい
• 制約
– 1≦N≦ 300

2023/1/20

20


• 今回の問題は、グラフにして考えると良い！
– グラフって？
• 丸（頂点）と、線（辺）で、様々な状態を表したもの！

– 例えばどう表すの？
• 下のような感じ
入力例１

1

10

2

入力例2
10

3

1

12

2

14

18

3
4

5
9
2023/1/20

7
21


• 最も良いバス停を探すには？
– 上手い方法を探すのは難しい！
• 以下のような例でも既にパッと見ではわからない
6

4

3

4

2

7
8

2023/1/20

22


• 最も良いバス停を探すには？
– 上手い方法を探すのは難しい！
– ではどうするか？
– 全てのバス停とバス停の間の距離を求めてしまえば良
い！
• でも、それって計算時間的に出来るの？

2023/1/20

23


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法

7
1
6

3

A

4

4
2023/1/20

B

2

3

24


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• まず始点に0を入れ、他の場所には大きな数を入れる

7
999

1

999

6

3

2

0

4
999

4
2023/1/20

999

999

3

25


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 各頂点のうち、最も数字の小さい頂点を選ぶ

7
999

1

999

6

3

2

0

4
999

4
2023/1/20

999

999

3

26


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• そこから、周りの値を更新していく

7
999

3
6

3

2

0

999

4
999

4
2023/1/20

1

4

3

27


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 今調べた頂点を使用済みとする

7
999

3
6

3

2

0

999

4
999

4
2023/1/20

1

4

3

28


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 再度、残った頂点から、最も数字の小さい頂点を選ぶ

7
999

3
6

3

2

0

999

4
999

4
2023/1/20

1

4

3

29


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 周りを更新する

7

10

3
6

3

2

0
4
2023/1/20

4

1

9
3

999

4

30


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 使用済みにする

7

10

3
6

3

2

0
4
2023/1/20

4

1

9
3

999

4

31


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 同様に繰り返す

7

10

3
6

3

2

0
4
2023/1/20

4

1

7
3

999

4

32


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 同様に繰り返す

7

9

3
6

3

2

0
4
2023/1/20

4

1

7
3

11
4

33


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 同様に繰り返す

7

9

3
6

3

2

0
4
2023/1/20

4

1

7
3

10
4

34


• 最短経路の求め方（ダイクストラ法）
– AからBへの最短経路を求める方法
• 同様に繰り返す

7

9

3
6

3

2

0
4
2023/1/20

4

1

7
3

10
4

35


• 最短経路の求め方（ダイクストラ法）
– 計算量はどれくらい？
– 頂点数をV、辺の数をEとする。
– アルゴリズムは以下のようになる
• V回ループを回す
– 最も数字（コスト）が少ない頂点を探す
– そこから、各辺について調べ、その先の頂点の数字を更新する

– 計算量は？

2023/1/20

36


• 最短経路の求め方（ダイクストラ法）
– 計算量はどれくらい？
– 頂点数をVEとする。
– アルゴリズムは以下のようになる
• V回ループを回す（最後の頂点まで調べる必要があるため）
– 最も数字（コスト）が少ない頂点を探す
– そこから、各辺について調べ、その先の頂点の数字を更新する

– 計算量は？
• 頂点を探す処理は、最大V個
• 各頂点から出ている辺も、重複さえなければ最大V個

– よって、O(V^2)となる。
2023/1/20

37


• AからBへの最短経路を求める計算がO(N^2)
– つまり、場所のペアの組み合わせはO(N^2)パターンある
から、合わせてO(N^4)？間に合わない？

2023/1/20

38


• AからBへの最短経路を求める計算がO(N^2)
– つまり、場所のペアの組み合わせはO(N^2)パターンある
から、合わせてO(N^4)？間に合わない？

• AからBへの最短経路を求めるだけでなく、Aから他
の全ての頂点までの最短経路をO(N^2)で求められ
るのがダイクストラ法
– よって、ダイクストラ法を使うのはN回で良く、O(N^3)
– N=300の時、N^3は2700万なので、高速な言語なら簡単
に通せる

2023/1/20

39


• その他の方法
– ワーシャルフロイドと呼ばれるアルゴリズムを使うと、凄く
簡単に求めることが出来る！
– ダイクストラ法との違い
• ダイクストラは、単一始点最短路を求めるアルゴリズム
– ある頂点を始点とした時、それ以外の頂点への最短路を求める

• ワーシャルフロイドは、全点対間最短路を求めるアルゴリズム
– 任意の頂点から任意の頂点までの最短路を求めるアルゴリズム
» 今回の目的にぴったり！

2023/1/20

40


• ワーシャルフロイド法の実装
– 非常に簡単、以下のようなアルゴリズムで実装可能！
– 各点同士の距離を表す配列distには、あらかじめ、以下のよう
に数字設定をする
• dist[i][i] = 0;
• dist[a_i][b_i] = dist[b_i][a_i] = t_i;
– 今回の問題では、両側に行けるので、両方に入れないとダメ！

• その他は、非常に大きい値を入れておく。
– 二つ足してもオーバーフローしない程度にしましょう！

For(int K = 0; K < N; K++)
For(int I = 0; I < N; I++)
For(int J = 0; j < N; j++)
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
2023/1/20

41


• ワーシャルフロイドの仕組み
For(int K = 0; K < N; K++)
For(int I = 0; I < N; I++)
For(int J = 0; j < N; j++)
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
• Kが中継点であり、中継点を全通り試している。
– 中継点を全部試せば、全ての点同士の最短経路を求め
られそう

2023/1/20

42


• ワーシャルフロイドのイメージ
– A,Bの最短経路が、A,C,F,D,E,Bだったとする
• 中継点はアルファベット順に調べるものとする

A

2023/1/20

C

F

D

E

B

43


• ワーシャルフロイドのイメージ
– A,Bの最短経路が、A,C,F,D,E,Bだったとする
• 中継点はアルファベット順に調べるものとする

– A,Bの最短路が正しく求められるには、最後の中継点Fを
調べる時に、A-Fの最短路と、F-Bの最短路が求まってい
れば良い

A

2023/1/20

C

F

D

E

B

44


• ワーシャルフロイドのイメージ
– A,Bの最短経路が、A,C,F,D,E,Bだったとする
• 中継点はアルファベット順に調べるものとする

– A,Bの最短路が正しく求められるには、最後の中継点Fを
調べる時に、A-Fの最短路と、F-Bの最短路が求まってい
れば良い
– A-Fの最短路は、A-Fにある最後の中継点Cを見た時に、AC、C-Fは１辺しかなく、A-Fの最短路がA,C,F,D,E,Bということ
は、A-C,C-Fはこれ以外のルートが最短であることはない
ので、最短路は正しく求まっている。
A

2023/1/20

C

F

D

E

B

45


• ワーシャルフロイドのイメージ
– A,Bの最短経路が、A,C,F,D,E,Bだったとする
• 中継点はアルファベット順に調べるものとする

– A,Bの最短路が正しく求められるには、最後の中継点Fを
調べる時に、A-Fの最短路と、F-Bの最短路が求まってい
れば良い
– F-B間の最短路も、同様にEから調べていけば、最短路が
順番に求まっていることが解る
• このように、最短路になる部分を再帰的に見ていくと、最短路が
順番に求まっていることが確認できる。
A

2023/1/20

C

F

D

E

B

46


• まとめ
– 全点対間最短経路を求める時には、ワーシャルフロイド
を使おう！
• 計算量はO(V^3)
– 疎なグラフ（辺が少ないグラフ）の時は、全点対間最短経路を求め
る時でも、優先度付きキューを利用したダイクストラを繰り返した方
が早いこともあるので一応注意

• 実装が凄く簡単！
– 4行でかける！

2023/1/20

47


• 注意点
– 遅い言語では通りません！
• Perl, Ruby, Pythonなど
• 計算量が一定以上重い問題だと、LL系の言語では、通すことが
出来ません。
– 言語の選択もコンテストのうちです！
– テストの作り方が甘いので、上手く誤魔化せば通るかも
» 各ノードのコストが少ない辺ベスト20だけでダイクストラとか。
» 普通に書いて通らないことは検証していますが、誤魔化して通るかは
未検証です。

2023/1/20

48


• おまけ
– ダイクストラ法は、O((E+V)logV)な書き方もあります。
• 優先度付きキューをうまいこと使えば良い

2023/1/20

49


