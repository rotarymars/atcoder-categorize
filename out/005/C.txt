1. 問題概要
2. アルゴリズム

2014/3/22

©AtCoder Inc. All rights reserved.

16


• たこ焼きは、出来てからT秒以内に売らなければな
らない。
• たこ焼きをN個作る
– 各たこ焼きはA_i秒後に作成される

• お客さんはM人くる
– 各お客さんはB_j秒後に訪れる

• 全てのお客さんに対し、作られてからT秒以内のた
こ焼きを提供できるかどうかを出力しなさい。

2014/3/22

17


• Sample5 T = 2
– 以下のように、客に対してたこ焼きを割り当てる
1

4

3
6

8

10
15

2014/3/22

16

18


• T = 1になった場合
– 割り当てることが出来なかったら失敗
1

4

3
6

8

10
15

2014/3/22

16

19


• 各お客さんに対し、どのたこ焼きを売るかを決める
– M人のお客さんに、N個のたこ焼きを1つずつ割り当て
る？
– 組み合わせの数は、N! / (N-M)!通り。
• N,Mともに上限は100
• N=M=100の時、100!通り存在する

• 2秒の制限時間で処理可能なのは、高速な言語でも
1億ループ程度まで。
– 全通りを試すことが出来ない！

2014/3/22

20


• 実行時間を早くするためには？
– 現在、明らかに無駄な組み合わせを大量に考えてしまっ
ている
– 無駄な組み合わせを取り除こう！

2014/3/22

21


• 明らかに無駄なパターン１
– A < Bの時、A番目のお客さんのたこ焼きより、B番目のお
客さんのたこ焼きの方が新しいケースは、考えなくて良い
• 後からきたお客さんに、先に来たお客さんよりも古いたこ焼きを
売る理由はない

– これだと、パターン数は大幅に減る！
• N個のたこ焼きから、M個のお客さんを選ぶ
– これは N! / (M! * (N-M)!)通り
– N=100, M=50が最大だが、これも非常に大きな数になってしまう

– これでも間に合わないので、もう少し無駄なパターンを削
る
2014/3/22

22


• 明らかに無駄なパターン2
– T秒以内に作られたたこ焼きの中で、最も古いたこ焼き以
外は考えなくても良い
• そうした方が、後のお客さんの選択肢が増える

• こうすると、実は売り方は１通りしかなくなってしまう
– 売れるたこ焼きがあれば、最も古いものを売る
– 売れるたこ焼きが無ければ、全員に対して、T秒以内に出
来たたこ焼きを全て売ることが出来ない。

2014/3/22

23


• 実装の流れ
– M人に対して、たこ焼きが売れるかどうかループを回して
判定を行う
• N個のたこ焼きに対してループを回し、まだ売られていないもので、
T秒以内に作られたものがあるかどうかを探す
– あれば、最も昔に作られたものを売る
– 外側にフラグか何かを立てておく
– なければ、noを出力して終了

– 全て売切れればyesを出力する
– ループの最大数はN * M回くらいなので、100程度であれ
ば十分間に合う
2014/3/22

24


• おまけ1
– 実装を工夫すると、1 <= N, M <= 100,000でも間に合う
– 工夫する点
• 前の人が食べたたこ焼きより、次の人が食べるたこ焼きは絶対に
後のものである
• つまり、前の人が食べたたこ焼きの次のたこ焼きから調べて良い
• さらに、早く作られたたこ焼きから順番に調べていき、売ることが
可能なたこ焼きが見つかったら、それより後のたこ焼きについて
調べる必要がない
• こうすると、同じたこ焼きを複数人に対して調べることがなくなる
• たこ焼き1つにつき調べる回数は1回なので、計算量はO(N)にな
る

2014/3/22

25


• 計算のイメージ
– こんな感じで、調べる範囲が被らない
1

3

6

10

15

4

8

16
2014/3/22

26


• おまけ2
– 二部グラフの最大マッチングでも解くことが可能
• ただし、大きなサイズになると解けない

– 興味のある人は、以下のワードで検索
• 二部グラフ
• 二部グラフの最大マッチング

2014/3/22

27


• こんな感じのグラフを作って、フローをM流す
– T = 5 のときのグラフ
– 流せればyes、流せなければno
1

S

3

4

6

8

10

16

T

15
2014/3/22

28

