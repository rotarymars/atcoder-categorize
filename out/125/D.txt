かっこいい解法
考察 1(重要). この問題のポイントは、「i を選んで Ai , Ai+1 をそれぞれ −Ai , −Ai+1 にする」操作を繰り返
すことで、
「x, y (x < y) を選んで Ax , Ay をそれぞれ −Ax , −Ay にする」ことがどの x, y についても可能で
あるということです。実際、i = x, x + 1, ..., y − 1 と選んで y − x 回操作を行えば Ax , Ay の符号のみが反転
します。
考察 2. 操作を通して、Ai は Ai または −Ai にしかなり得ません。
考察 3. Ai = 0 となる i が存在しない場合、操作によって Ai < 0 となる i の数の偶奇は変化しません。
したがって、初期状態で負の数が偶数個の場合、または Ai = 0 となる i が存在する場合、全てを非負にで
きるため、S = |A1 | + |A2 | + ... + |AN | とすると、答えは S になります。そうでない場合、全てを非負には
できませんが、好きな 1 つを除いて全てを非負にできます。負のままにしておく数は、絶対値が最小のものを
選ぶのが最適なので、答えは S − 2 × min{|A1 |, |A2 |, ..., |AN |} になります。時間計算量は O(N ) なので十分
間に合います。

アルゴリズムで殴る解法
実は、このような性質を見つけなくとも動的計画法で殴ることができます。同じ i を選んで反転することは
無駄なので、各 i について高々 1 回反転することを左から順に考えていきます。

i ∈ {0, 1, ..., N }, j ∈ {0, 1} に対して dp(i, j) を、A1 , A2 , ..., Ai を確定し、j = 1 なら i を選んで反転した
場合 (すなわち Ai+1 の符号が反転している状態) の A1 + A2 + ... + Ai の最大値と定義します。すると、次
の漸化式を計算することで各 i, j に対する dp(i, j) を求めることができます。

dp(0, 0) = 0
dp(0, 1) = −∞ (invalid)
dp(i + 1, 0) = max(dp(i, 0) + Ai , dp(i, 1) − Ai )
dp(i + 1, 1) = max(dp(i, 0) − Ai , dp(i, 1) + Ai )
N を選んで操作することはできないため、答えは dp(N, 0) です。時間計算量はかっこいい解法と同じく
O(N ) なので十分間に合います。

4


