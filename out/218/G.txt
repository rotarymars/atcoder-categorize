
		公式
		
			
				G - Game on Tree 2 解説
			
			by  blackyuki
			
		
		
		
		
			頂点 \(1\) を根とすると、駒は葉に向かって移動するだけなので、ゲーム終了時点での駒の位置によってそれまでに通った頂点とその中央値が一意に定まります。

全ての葉に対して、その頂点でゲームが終了したときの中央値を求めることさえできれば、木DPでこの問題が解けます。

よって DFS をしながら以下の処理が高速にできれば良いです。


数の（多重）集合 \(S\) に \(X\) を追加する。
\(S\) から \(X\) を削除する。
\(S\) の中央値を求める。


以下の2つの手法が考えられます。

1. BIT上の二分探索解

あらかじめ座標圧縮しておくことで、追加クエリと削除クエリは一点加算、中央値を求めるクエリは BIT 上の二分探索に置き換えられます。
計算量は \(O(NlogN)\) または \(O(Nlog^2N)\) です。

2. std::multiset解

小さい方半分と大きい方半分を管理する \(2\) つの multiset を用意します。常に要素数が半分ずつとなるようにすることで、クエリあたり \(O(logN)\) で処理できます。
以下の実装例はこちらの方針です。
計算量は \(O(NlogN)\) です。

実装例 (C++)



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
