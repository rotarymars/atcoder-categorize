
33

問題概要
• 以下のような0/1ナップサック問題を解いてください．
• N個の荷物があって，それぞれの荷物には価値と重さが割り当てられている．
• 重さの総和がW以下となるように荷物を選ぶとき，価値を最大化してください．
• ただし，
A) Nが30以下のケース
B) 全ての荷物の価値が1000以下のケース
C) 全ての荷物の重みが1000以下のケース

• の少なくともの1つが成り立つケースしかデータセットに存在しない．

• 1 ≦ 𝑁 ≦ 200
• 1 ≦ 荷物の価値𝑣𝑖 , 荷物の重み𝑤𝑖 ≦ 109
• 1 ≦ 𝑊 ≦ 109
34

はじめに
• ナップサック問題は，動的計画法(DP)を用いる例題としてとても有名
• 聞いたことがない人は，本やインターネットに図解が溢れかえっているので
是非調べてみましょう
• 今回は文章だけです．

• ナップサック問題は，
• 重さの和や価値の和に関して上限がないとき

→NP困難問題として有名で，多項式時間では解けない
• 重さの和や価値の和に制約があるとき
→計算量がそれらの値に依存する擬多項式時間アルゴリズムがある
(よくあるDPのことです)
35

考察
• 各データセット毎に場合分けして解く他ない．
A) Nが30以下のケース
→ DPは困難∧愚直な全列挙は難しい(枝刈り探索なら通るかも..?)
B) 全ての荷物の価値が1000以下のケース
→ DPできる
C)全ての荷物の重みが1000以下のケース
→DPできる

• それぞれについて考える
36

考察＆解法 (A) Nが30以下のケース
• 価値・重みに制約が無いため動的計画法は困難
• 𝑂(2𝑁 )で全列挙は間に合わなさそう．
• 与えられた荷物の集合を半分ずつの集合A,Bに分けて，それぞれの
集合で組み合わせを全列挙し，それらの結果をうまくマージすると，
𝑁
𝑁
𝑂(2 2 ∗ log 𝑆)程度の計算量で解ける(𝑆 = 2 2 とする)．
• そのために，まず集合Aに対して，重さの和𝑥以下で達成できる最大価値を
𝑂(log 𝑆)程度で求めれるようにしておく必要がある．
• S通りある(重みの和,価値の和)のペアを辞書順ソートして，重みに対して価
値が単調増加するようにリストを作っておけば二分探索できる．
• その後，集合Bのある組み合わせを試して，その組み合わせを使った後余る
重みを集合Aに割り振る．この時達成できる最大価値を先ほどのリストに対
37
する二分探索等で高速に求める．

アルゴリズムの流れ (A) Nが30以下のケース
① 荷物を2つの集合に分ける
(𝑣1 = 5, 𝑤1 = 2)
(𝑣2 = 4, 𝑤2 = 3)
(𝑣3 = 1, 𝑤3 = 1)
(𝑣4 = 2, 𝑤4 = 2)

A
(𝑣1 = 5, 𝑤1 = 2)
(𝑣2 = 4, 𝑤2 = 3)

全体
B
(𝑣3 = 1, 𝑤3 = 1)
(𝑣4 = 2, 𝑤4 = 2)

38

アルゴリズムの流れ (A) Nが30以下のケース
② Aの全組み合わせを計算してリストを作り，明らかに損するもの(そ
れ未満の重みで，それ以上の価値を達成するものがある組み合わ
せ)を取り除く．
重みでソート済みのリスト
得られたリスト

A
(𝑣1 = 5, 𝑤1 = 2)
(𝑣2 = 4, 𝑤2 = 3)

この例では
全4通り計算

(v=0,w=0)
(v=5,w=2)
(v=4,w=3)
(v=9,w=5)

要らないものを削除

(v=0,w=0)
(v=5,w=2)
(v=9,w=5)
39

アルゴリズムの流れ (A) Nが30以下のケース
③ Bの全組み合わせに対して，先ほど計算したリストのどの要素と
くっつければ良いかを，重みに対する二分探索で計算し，マージする
例)ナップサックのサイズが5の場合を考えると以下のようになる
集合Aから得たリスト

B
(𝑣3 = 1, 𝑤3 = 1)
(𝑣4 = 2, 𝑤4 = 2)

この例では
全4通り計算

(v=0,w=0)
(v=1,w=1)
(v=2,w=2)
(v=3,w=3)

(v=0,w=0)
(v=5,w=2)
(v=9,w=5)
40

考察＆解法 (B)荷物の価値が1000以下
• 𝑉𝑀𝐴𝑋 = 1000とおくと，価値の総和は高々 𝑁 ∗ 𝑉𝑀𝐴𝑋 (= 20万) 以下．
• 価値に対して重みを最小化するDPができる．
• 𝑑𝑝[𝑖][𝑗] ∶= 𝑖番目のアイテム(𝑖 = 1. . 𝑁)まで使って，価値の和jを達成す
る重みの和の最小値
と定義すると，以下の漸化式を計算すれば解ける
• 𝑑𝑝[0][0] = 0, 𝑑𝑝[0][1. . 𝑁𝑉𝑀𝐴𝑋 ] = ∞
• 𝑑𝑝[𝑖][𝑗] = min(𝑑𝑝[𝑖 − 1][𝑗], 𝑑𝑝[𝑖 − 1][𝑗 − 𝑣𝑖 ] + 𝑤𝑖 (但し𝑗 − 𝑣𝑖 ≧ 0の時) )

• この漸化式を𝑖 = 0. . 𝑁に対して計算した後，重みの和が 𝑊 以下となる
最大の価値をテーブルを参照して求めれば良い．
41

考察＆解法 (B)荷物の価値が1000以下
• 実は，価値の逆順に更新ループを行うと，テーブルのサイズが
𝑂(𝑁𝑉𝑀𝐴𝑋 )で済み，添字iについて考慮しなくてよくなる．実装も軽い．
• 時間計算量は 𝑂(𝑁 2 𝑉𝑀𝐴𝑋 ) 空間計算量は 𝑂 𝑁𝑉𝑀𝐴𝑋
配列𝑑𝑝[0. . 𝑁][0. . 𝑁𝑉𝑀𝐴𝑋 ]を用意
省メモリ
𝐹𝑜𝑟 𝑖 = 1. . 𝑁𝑉𝑀𝐴𝑋
実装が楽
𝑑𝑝 0 𝑖 = ∞
𝑑𝑝[0][0] = 0
𝐹𝑜𝑟 𝑖 = 1. . 𝑛
𝐹𝑜𝑟 𝑗 = 0 . . (𝑣𝑖 − 1)
𝑑𝑝[𝑖][𝑗] = 𝑑𝑝[𝑖 − 1][𝑗];
𝐹𝑜𝑟 𝑗 = 𝑣𝑖 . . 𝑁𝑉𝑀𝐴𝑋
𝑑𝑝[𝑖][𝑗] = min(𝑑𝑝[𝑖 − 1][𝑗], 𝑑𝑝[𝑖 − 1][𝑗 − 𝑣𝑖 ] + 𝑤𝑖 )

配列𝑑𝑝[0. . 𝑁𝑉𝑀𝐴𝑋 ]を用意
𝐹𝑜𝑟 𝑖 = 1. . 𝑁𝑉𝑀𝐴𝑋
𝑑𝑝[𝑖] = ∞
𝑑𝑝[0] = 0
𝐹𝑜𝑟 𝑖 = 1. . 𝑛
𝐹𝑜𝑟 𝑗 = 𝑁𝑉𝑀𝐴𝑋 . . 𝑣𝑖 (※逆順)
𝑑𝑝[𝑗] = min(𝑑𝑝[𝑗], 𝑑𝑝[𝑗 − 𝑣𝑖 ] + 𝑤𝑖 )

42

考察＆解法 (C)荷物の重みが1000以下
• これが一番お馴染みかも知れない．
• 𝑊𝑀𝐴𝑋 = 1000とおくと，重みの総和は高々 𝑁 ∗ 𝑊𝑀𝐴𝑋 (= 20万) 以下．
• 重みに対して価値を最大化するDPができる．
• 𝑑𝑝[𝑖][𝑗] ∶= 𝑖番目のアイテム(𝑖 = 1. . 𝑁)まで使って，重みの和jを達成す
る価値の和の最大値
と定義すると，以下の漸化式を二重ループで計算すれば解ける
• 𝑑𝑝 0 0 = 0, 𝑑𝑝 0 1. . 𝑁𝑊𝑀𝐴𝑋 = −∞
• 𝑑𝑝[𝑖][𝑗] = m𝑎𝑥(𝑑𝑝[𝑖 − 1][𝑗], 𝑑𝑝[𝑖 − 1][𝑗 − 𝑤𝑖 ] + 𝑣𝑖 (但し𝑗 − 𝑤𝑖 ≧ 0の時) )

• 後は重みW以下で価値が最大のものを求めれば良い．
• さっきのスライドで説明した価値のDPとやり方はほぼ同じ
43

考察＆解法 (C)荷物の重みが1000以下
• これも重みの逆順に更新すれば，
時間計算量は 𝑂(𝑁 2 𝑊𝑀𝐴𝑋 ) 空間計算量は 𝑂 𝑁𝑊𝑀𝐴𝑋

44


