
		公式
		
			
				D - Avoid K Palindrome 解説
			
			by MMNMM
			
		
		
		
		
			A, B, ? からなる文字列 \(T\) に対して、\(\operatorname{dp} _ T[P]\) を次のように定めます。


\(T\) に含まれる ? をそれぞれ A, B に置換してできる文字列のうち、次の \(2\) つの条件をどちらも満たすものの個数


良い文字列である
末尾 \(\min\lbrace K-1,|T|\rbrace\) 文字が文字列 \(P\) と等しい



A, B, ? からなる文字列 \(T\) について、ありえるすべての \(P\) に対する \(\operatorname{dp} _ T[P]\) の値がわかっているとします。
このとき、\(\operatorname{dp} _ {T+\mathtt{A}}[P]\) や \(\operatorname{dp} _ {T+\mathtt{B}}[P],\operatorname{dp} _ {T+\mathtt{?}}[P]\) の値が高速に求められれば、動的計画法を用いてこの問題を解くことができます（ここで、文字列 \(X\) の末尾に文字 \(c\) を追加したものを \(X+c\) と書いて表すこととします）。

\(\operatorname{dp} _ T\) の値から \(\operatorname{dp} _ {T+\mathtt A}\) を求めるアルゴリズムについて考えます（B に対してもほぼ同じで、? に対してはこれらの和を求めればよいです）。


はじめ、どのような \(P\) に対しても \(\operatorname{dp} _ {T+\mathtt A}[P]=0\)  として初期化する。
ありえる \(P\) すべてに対して、次を行う。


\(P+\mathtt A\) が長さ \(K\) の回文なら、なにもしない。
そうでなければ、\(P+\mathtt A\) の末尾 \(\min\lbrace K-1,|P|+1\rbrace\) 文字を取った文字列を \(P ^ \prime\) として \(\operatorname{dp} _ {T+\mathtt A}[P ^ \prime]\) に \(\operatorname{dp} _ T[P]\) を加える。



これを用いて与えられた文字列 \(S\) に対する \(\operatorname{dp} _ S\) を求めることを考えます。
これは、回文判定に \(\Theta(K)\) 時間かけた場合でも全体で \(O(2 ^ KKN)\) 時間となり、十分高速です。

実装の方針として、DP テーブルのキーとして文字列を使う方針や非負整数を使う方針があります。

文字列を使うと、キーがわかりやすく、長さが \(K\) 未満の文字列に対する DP テーブルを求める際に番兵を用いた実装を使うことで実装をシンプルにしやすいですが、定数倍が悪い場合があります。
非負整数を使うと、時間・空間計算量の定数倍がよいですが、実装が煩雑になる場合があります。

実装例は以下のようになります。

C++ での実装例では DP テーブルのキーを非負整数とし、\(S\) が短い部分の処理を別に分けています。
Python での実装例では DP テーブルのキーを文字列とし、番兵を置くことで実装を単純にしています。





		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
