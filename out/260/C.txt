
		公式
		
			
				C - Changing Jewels 解説
			
			by  Nyaan
			
		
		
		
		
			この問題は 再帰関数 ・ 動的計画法 のいずれかを用いると解くことができる問題です。
再帰関数・メモ化再帰・動的計画法に関しては以前に ABC247-C の解説 でも説明したので、再帰関数や動的計画法を知らない人はそちらの問題を解いて解説を読んでみるとよいでしょう。

1.動的計画法

解法の 1 つは動的計画法(通称 DP) です。

\(r_1, r_2, \dots, r_N\) および \(b_1, b_2, \dots, b_N\) を次のように定義します。


\(r_i\) : レベル \(i\) の赤い宝石を \(1\) 個持っている状態からはじめて、入手できるレベル \(1\) の青い宝石の個数
\(b_i\) : レベル \(i\) の青い宝石を \(1\) 個持っている状態からはじめて、入手できるレベル \(1\) の青い宝石の個数


まず、\(r_1, b_1\) は次のように定まります。


レベル \(1\) の赤い宝石からレベル \(1\) の青い宝石は得られない。よって \(r_1 = 0\) である。
レベル \(i\) の青い宝石 \(1\) 個からレベル \(1\) の青い宝石は(少し奇妙な表現になるが)ちょうど \(1\) 個得られる。 よって \(b_1 =1\) である。


次に、\(r_i,b_i\) \((i \geq 2)\) は問題文の定義から次の式で表せます。
\[
\begin{aligned}
b_n &= r_{n-1} + b_{n-1} \times Y\\
r_n &= r_{n-1} + b_{n} \times X\\
\end{aligned}
\]よって、上の式に従って \(r_n, b_n\) を \(n=1\) から \(n=N\) の順に計算していけばよいです。


注意すべき点として、\(r_n\) より先に \(b_n\) を計算する必要がある点があります。なぜならば、\(r_n\) を求めるのに \(b_n\) の値が必要だからです。


実装は以下の通りです。



2. 再帰関数

もう一つの解法は再帰関数を用いる解法です。
再帰とは、ある物事を説明するときに、それ自身が説明の中に入っていることを言います。1. の解法を見るとわかる通り、ある宝石から得られるレベル \(1\) の青い宝石の個数は他のある宝石から得られるレベル \(1\) の青い宝石の個数によって定まるものであり、再帰的な関係にあると言えます。
再帰関数とは、関数の内部で自分自身を呼び出す関数のことを言います。上に説明したような再帰的な構造は、再帰関数を用いるとそのまま実装することができます。
具体的には、1. の解法と同様の式を再帰関数の形で実装すればよいです。実装は以下の通りです。




これは余談ですが、赤い宝石と青い宝石で別々の再帰関数を使おうとすると 相互再帰 と呼ばれる状態になって、言語によっては実装が複雑になります。(例えば C++ ではプロトタイプ宣言が必要になります。)初心者の方は上の実装のように 1 つの関数で再帰するようにした方が簡明でしょう。


		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
