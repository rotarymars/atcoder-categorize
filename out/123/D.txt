この問題では、一番単純な解法として、𝑋𝑌𝑍   通りを全探索して、全てのコストの合計をソートして、
大きい順から  𝐾  番目までを順に出力する、という方法が考えられます。
しかし、𝑁   要素のソートの計算量は  𝑂(𝑁log𝑁)   です。[1]   そのため、この単純な解法の計算量は
𝑂(𝑋𝑌𝑍log𝑋𝑌𝑍)   となり、𝑋,𝑌,𝑍=1000   の時  3×1010   回程度の計算がかかり、実行時間制限の
2  秒に間に合いません。

そこで、ある工夫をするとこの問題が解けます。解法は色々とあり、今回はこのうちの  4  通りを説明し
たいと思います。

解法 #1 – 工夫したソートで 𝑶(𝑲𝟐𝐥𝐨𝐠𝑲)
1  つ目の解法として、以下のような方法が考えられます。
➢ まず、最初の  2  種類のケーキ（’1’,  ‘2’  の形のキャンドルが付いたもの）だけを考えて、𝑋𝑌  通
りの中で上位  𝐾   通りを順に求める。そこで、𝐴𝑖 +𝐵𝑗   でソートし、その中の  𝑘   番目  (1≤𝑘 ≤
𝐾)  を  𝐸𝑘  とする。
➢ 次に、最後のケーキ（’3’  の形のキャンドルが付いたもの）を考える。最終的な美味しさの合計
が上位  𝐾   番目までに入るようなケーキの選び方は、最初の  2  種類のケーキだけを考えても上
位  𝐾   番目までに入らなければならないので、𝐸𝑖 +𝐶𝑗 (1≤i,j≤K)   でソートして、1,2,3,...,K
番目の値が答えである。

例えば、𝐴={1,2,3},𝐵 ={1,5,7},𝐶 ={1,9,3},𝐾 =5  のとき、
➢ 𝐴𝑖 +𝐵𝑗  でソートした時の上位  5  番目までの値（𝐸1 ~ 𝐸5)  は  {10,9,8,8,7}  である
➢ 上位  9  番目までを見ると、{10,9,8,8,7,6,4,3,2}
➢ 次に、𝐸𝑖 +𝐶𝑗  でソートした時の上位   5  番目までの値は、{19,18,17,17,16}  である。
➢ 上位  15  番目までを見ると、{19,18,17,17,16,13,12,11,11,11,10,10,9,9,8}
➢ よって、𝑋𝑌𝑍 個の中の上位  5  個は  {19,18,17,17,16}  である。

この解法を用いると、高々  𝑂(𝑋𝑌+𝐾𝑍)   個をソートする必要がありますが、𝑋,𝑌,𝑍≤1000,𝐾 ≤
3000  より実行時間制限に間に合います。

解法 #2 – 「ある条件」 を満たす最大 106307 通りを全部ソート
2  つ目の解法として、以下のような定理を使います。






実際に、上の定理の条件を満たさない  (つまり、𝑎×𝑏×𝑐 ≤𝐾   である)  ようなケーキの選び方は、
𝑋,𝑌,𝑍 =1000,𝐾 =3000   の場合  106,307   通りあります。そうすると、条件を満たす  106,307   通り
全てをソートしても、計算量的には全く問題がありません。
また、一般の  𝐾   に対して、𝑎×𝑏×𝑐 ≤𝐾   であるケーキの選び方は高々  𝑂(𝐾log2𝐾)   通りです。
つまり、この解法の計算量は  𝑂(𝐾log3𝐾)  です。

以下のようなコードを書くと正解します。

【定理】
以下のような選び方は、上位  𝐾  個には絶対入っていない。
⚫ 高橋君が選んだ  ‘1’  の形のキャンドルが付いたケーキが、それらのケーキの中で  𝑎   番目に
美味しいとする。(1≤𝑎≤𝑋)
⚫ 高橋君が選んだ  ‘2’  の形のキャンドルが付いたケーキが、それらのケーキの中で  b   番目に
美味しいとする。(1≤𝑏≤𝑌)
⚫ 高橋君が選んだ  ‘3’  の形のキャンドルが付いたケーキが、それらのケーキの中で  c   番目に
美味しいとする。(1≤𝑐 ≤𝑍)
⚫ そのとき、𝑎𝑏𝑐 >𝐾   の場合、絶対に上位  𝐾   個には入っていない。具体的には、一番順位
が高い場合でも上から  𝑎𝑏𝑐  番目である。
解法 #3 – さらに高速な解法、priority-queue を用いて 𝑶(𝑲 𝐥𝐨𝐠𝑲)
この問題は、以下のようなアルゴリズムによって  𝑂(𝐾log𝐾) で解くことができます。















実際に、このアルゴリズムは正しく動作します。
理由は、𝑓(𝑎,𝑏,𝑐)   の値を  「𝐴𝑎 +𝐵𝑏 +𝐶𝑐   という選び方の美味しさの合計が上から何番目か、とい
う値」  とするとき 、𝑓(𝑎,𝑏,𝑐)<𝑓(𝑎+1,𝑏,𝑐),𝑓(𝑎,𝑏,𝑐)<𝑓(𝑎,𝑏+1,𝑐),𝑓(𝑎,𝑏,𝑐)<𝑓(𝑎,𝑏,𝑐+1)
が成り立つからです。

Priority Queue  の挿入・削除・一番大きい値を求めるといった操作は  𝑂(log𝐾) で動作するので、
この問題を  𝑂(𝐾log𝐾)  と、前  2  つの解法より大幅に高速に解くことができます。
なお、Priority Queue (優先度付きキュー)  を知らない人は参考文献[2]  を参考にしてください。

⚫ 数列  𝐴,𝐵,𝐶   (各形のキャンドルが付いたケーキ)  を降順ソートする。そして、𝐴𝑖   が  𝑖   番目
に美味しい  ‘1’  の形のキャンドルが付いたケーキとなるようにする。𝐵𝑗,𝐶𝑘   に関しても同様と
する。
⚫ Priority Queue (優先度付きキュー)  である 𝑄  を定義する。
⚫ 𝑄   に  (𝐴1 +𝐵1 +𝐶1,1,1,1 )   を追加する。なお、𝐴1 +𝐵1 +𝐶1   が  1  番目の美味しさの
合計であることが保証されている。
⚫ 以下の操作を  𝐾  回繰り返す。
➢ 𝑄  の中で一番大きい要素を  (𝑝,𝑖,𝑗,𝑘)  とする。この組が  𝑡  番目の美味しさの合計で
ある。ただし、ここで行っている操作が  𝑡  回目の操作であるとする。
➢ 𝑄  の中で一番大きい要素を削除する。
➢ (𝐴𝑖+1 +𝐵𝑗 +𝐶𝑘,𝑖+1,𝑗,𝑘)  がまだ追加されたことが無ければ  𝑄  に追加する。
➢ (𝐴𝑖 +𝐵𝑗+1 +𝐶𝑘,𝑖,𝑗+1,𝑘)  がまだ追加されたことが無ければ  𝑄  に追加する。
➢ (𝐴𝑖 +𝐵𝑗 +𝐶𝑘+1,𝑖,𝑗,𝑘+1)  がまだ追加されたことが無ければ  𝑄  に追加する。
解法 #4 – 二分探索で 𝑶(𝑲𝐥𝐨𝐠𝒎𝒂𝒙)
まず、「上から  𝐾  番目の美味しさにランクインするボーダーの値」  を求めることを考えます。
前提として、ここでは数列  𝐴,𝐵,𝐶  がソートされているものとします。

ボーダーの値は、二分探索によって求めることができます。
さて、「美味しさの合計が 𝑷 以上である個数が 𝑲 個以上あるかどうかを高速判定する方法」  は
どのように求めればよいのでしょうか。これは、単純な枝刈り全探索で  𝑂(𝐾2)   あるいは  𝑂(𝐾+𝑋+𝑌+
𝑍)  で解くことができます。
以下は、枝刈り全探索の疑似コードです。


上の太字部分が求まれば、𝑃  を二分探索するだけで、𝐾  位以内にランクインするためのボーダーの美
味しさの合計値が求まります。

あとは、ボーダーの値を  𝐵𝑜𝑟𝑑𝑒𝑟  とするとき、以下の方法で上位  K 個 を求めることができます。
➢ 𝐵𝑜𝑟𝑑𝑒𝑟+1   以上であるものを全部列挙する。なお、列挙する方法は上の疑似コードにおいて、
𝐵𝑜𝑟𝑑𝑒𝑟+1  以上であるものすべてについて  𝐴𝑖 +𝐵𝑗 +𝐶𝑘  を記録すればよい。
➢ 列挙した個数が  𝐾  個に満たなければ残りは全部美味しさの合計が  𝐵𝑜𝑟𝑑𝑒𝑟  である。
➢ これらを降順ソートしたものが、上位  𝐾  番目まで、つまり答えである。

計算量は  𝑂(𝐾2log𝑚𝑎𝑥)   です。実装を工夫すると、𝑂((𝐾+𝑋+𝑌+𝑍)log𝑚𝑎𝑥)  程度で解くこ
とができます。

ソースコード (C++, 解法 2)：https://atcoder.jp/contests/abc123/submissions/4841936
参考文献
[1] https://qiita.com/drken/items/18b3b3db5735241465ef  の  3-2.  節
[2] https://ja.wikipedia.org/wiki/優先度付きキュー
