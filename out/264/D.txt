
		公式
		
			
				D - "redocta".swap(i,i+1) 解説
			
			by physics0523
			
		
		
		
		
			
解法1. 探索する

\(S\) から始めて atcoder にするまでに操作が最小で何度必要かどうかを、現在の文字列を頂点とみなして幅優先探索の要領で探索することができます。
実装の過程で、 queue(キュー) や map(連想配列) などを利用すると便利です。

計算量は文字列の長さを \(|S|\) として \(O(|S|!)\) です (が、今回は \(|S|=7\) で固定であるため計算量は定数時間となります。)

実装例(C++):



解法2. 「転倒数」を利用する

atcoder は \(7\) 文字全てが異なることに注意すると、 atcoder の \(i\) 文字目を整数 \(i\) に置き換える操作を考えることができます。
例えば、 catredo という入力を \((3,1,2,7,6,5,4)\) という数列に置き換えることができます。
この数列を \((1,2,3,4,5,6,7)\) に並べ替えるために必要な隣接要素の交換の最小回数は、「転倒数」という名前の付いた有名問題です。
具体的な解法はここでは省略しますが、例えば Chokudai Speedrun 001-J がこの「転倒数」を求める問題そのものです。
計算量は \(O(|S| \log |S|)\) です (が、先ほど同様 \(|S|=7\)  で固定なのでこちらも定数時間です。)

実装例(C++):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
