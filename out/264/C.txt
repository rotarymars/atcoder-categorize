
		公式
		
			
				C - Matrix Reducing 解説
			
			by leaf1415
			
		
		
		
		
			元の問題文のように \(1\) つずつ行や列を削除するのではなく、
「初期状態の \(A\) からいくつか（ \(0\) 個でも良い）の行と列を選んで、選んだ行と列たちを同時にまとめて削除する」
のをちょうど \(1\) 回やると考えても問題ありません。
例えば、下記の入力例１の \(A\) からは、



\(1\) 行目、\(3\) 行目、\(2\) 列目、\(5\) 列目を選んで同時に削除することで、
下記の入力例１の \(B\) と一致させることができます。



操作によって \(A\) を \(B\) と一致させることができるかを判定するには、
「 \(H_1\) 個の行のそれぞれについて、その行を削除するかどうか」を選ぶ \(2^{H_1}\) 通りの方法と、
「 \(W_1\) 個の列のそれぞれについて、その列を削除するかどうか」を選ぶ \(2^{W_1}\) 通りの方法の組み合わせ（全 \(2^{(H_1+W_1)}\) 通り）のすべてを実際に試して、その中に操作後の \(A\) が \(B\) と一致するものがあるかを判定すれば良いです。

\(2^{(H_1+W_1)}\) 通りある行と列の選び方の組み合わせを列挙するには、bit全探索と呼ばれる以下に述べる方法を用いるのが簡潔でしょう。
「 \(H_1\) 個の行のそれぞれについて、その行を削除するかどうかを選ぶ選び方」のそれぞれを、下記を満たすような \(2\) 進数表記で \(H_1\) 桁の非負整数 \(X\) で表現します。


\(i = 0, 1, 2, \ldots, H_1-1\) について


\(i\) 行目を削除するときは、\(X\) の下から \(i\) 桁目は \(1\) であり、
\(i\) 行目を削除しないときは、\(X\) の下から \(i\) 桁目は \(0\) である。



例えば、\(5\) 個の行のうち \(1\) 行目と \(3\) 行目を削除するという選び方は、
\(2\) 進数表記で \(00101\) と表せます。
このようにして、\(2^{H_1}\) 通りある行の選び方は、
\(2\) 進数表記でそれぞれ \(000\cdots 00, 000\cdots 01,  \ldots, 111\cdots 11\) 、
すなわち、\(10\) 進数表記でそれぞれ \(0, 1, \ldots, 2^{H_1}-1\) で表現できます。
同様に、「 \(W_1\) 個の列のそれぞれについて、その列を削除するかどうかを選ぶ選び方」も、\(0, 1, \ldots, 2^{W_1}-1\) と表現できます。

よって、行の選び方 \(0, 1, \ldots, 2^{H_1}-1\) を走査するループと、列の選び方 \(0, 1, \ldots, 2^{W_1}-1\) を走査するループの、二重ループによって行の選び方と列の選び方の組み合わせを全探索できます。その二重ループの内部で、それぞれの行と列の選び方が \(A\) を \(B\) に一致させるかを判定すれば良いです。

以下に、C++ 言語による正解例を記載します。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
