1. 問題概要
2. アルゴリズム

2015/2/28

©AtCoder Inc. All rights reserved.

10


• 魔法の箱に整数を入れると、それに対応した整数が
出てくる。
• 任意の整数 x について、 x を入れた時に出てくる整
数は、 2x の時と等しい
• N 個の整数 ai を魔法の箱に入れた時、最大何種類
の整数が得られるか。
• 制約
– 1<= N <=10^5, 1<=ai<=10^9
– 20点: 1<=N<=3000
– 50点: 1<=ai<=500000
2015/2/28

11


• ある数 x に対する結果と 2x に対する結果が同じな
ので，ai が2で割り切れなくなるまで2で割り続けても
よい．
• この処理で，ai がすべて奇数になった問題にするこ
とができる．逆に，奇数で異なる数に対する答えを
まとめて求めることは不可能．
• よって，あとは異なる ai の数を求めればよい．

2015/2/28

12


• 20点解法
– n<=3000 なので，ai が aj (1<=j<i) のいずれかに等しいかを
すべてチェックしてもOK．
– いずれにも等しくないとき，ai の種類を1増やす．

• 30点解法
– ai<=300000 なので，ある数が現れたかどうか，という長さ
300000 の配列を取り，それぞれの ai について，現れたこ
とをメモする．
– 最後に現れたことのある数を数える．

• 合わせて50点
– if(N<=3000) solve20();
else solve30(); のようにして，1つの提出の中に組み込む．
2015/2/28

13


• 満点解法では，N個の数の中から異なる数を効率的
に数えなければならない．
• std::set(C++) や HashSet(Java) を使う解法
– これらは要素の重複を許可しないので，同じ値が来ると
自動で捨ててくれる
– ai をこれらのデータ構造に詰め込んで，最終的な要素の
数が答え．

• ソートを使う方法
– ai をソートし，初めから見ていく．ある値を見つけたら，答
えを1増やし，そこから連続した同じ値の場所をスキップし
て，次の値の場所へ移動，を繰り返す(問題Bと似てる)
2015/2/28

14

