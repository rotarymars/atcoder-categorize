
		公式
		
			
				G - Generate Arrays 解説
			
			by MMNMM
			
		
		
		
		
			\(i\) 回目の操作の直後における \(i\) 番の列の長さ \(l _ i\) と \(s _ i\) 番の列の長さ \(l _ {s _ i}\) について、\(i\) 回目の操作を \(O(1+\min\lbrace l _ i,l _ {s _ i}\rbrace\log N)\) 時間でシミュレーションすることができれば、クエリ全体を \(O(Q+N(\log N) ^ 2)\) 時間で処理することができます。

計算量解析の概説

いわゆる、「マージテクの逆」です。

操作を逆から見ると、長さ \(a,b\) の列を \(O(1+\min\lbrace a,b\rbrace\log\min\lbrace a,b\rbrace)\) 時間かけてマージすることになります（ここで、マージする方法については考えません）。
これは全体に \(O(1)\) 時間と、短いほうの列の要素に対してそれぞれ \(O(\log N)\) 時間の処理を行っているとみることができます。

各要素の全体の計算量への寄与を考えると、処理が行われるたびに含まれている列の長さが倍以上になるため、処理はたかだか \(\log _ 2N\) 回しか行われません。

よって、全体の計算量は \(O(Q+N(\log N) ^ 2)\) となります。



それぞれの操作を \(O(1+\min\lbrace l _ i,l _ {s _ i}\rbrace\log N)\) 時間で処理するためには、平衡二分探索木や連結リストを用いるのがよいです。

例えば、std::set を用いて \(\bigl\lbrace(i,A _ i)\bigr\rbrace\) と \(\bigl\lbrace(A _ i,i)\bigr\rbrace\) をそれぞれ管理することで、それぞれのクエリを十分高速に処理することができます。

実装例は以下のようになります。
以下の実装例では、\(\bigl\lbrace(A _ i,i)\bigr\rbrace\) を管理する平衡二分探索木を \(2\) つに分けることで \(x _ i\) と中央値との大小関係がすぐにわかるようにしています（このようにしなくても、両端から進んで先に「 \(x\) より大」の境界線をまたぐのはどちらか判定することで十分高速になります）。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
