
		公式
		
			
				G - Replace 解説
			
			by mechanicalpenciI
			
		
		
		
		
			動的計画法によって、ある \(1\) 文字 \(c\) から、\(T\) の部分文字列 \(T_iT_{i+1}\ldots T_j\) を作るのに必要な最小コスト\(dp[i][j][c]\) (不可能な場合は \(+\infty\) ) を求める事を考えます。
さらに、これを求めるために別の動的計画法を同時に回します。
それは、\(A_k\) の先頭 \(l\) 文字 \(A_{k,1}\ldots A_{k,l}\) から \(T_iT_{i+1}\ldots T_j\) を作るのに必要な最小コスト\(dp'[i][j][k][l]\) (不可能な場合は \(+\infty\) ) を求めるものです。

\(i\)について \(i=N,N-1,\ldots,1\)、\(j\) について \(j=i,i+1,\ldots,N\) の順でループを回し、\(dp'[i][j][k][l]\) \((l>1)\) \(\to\) \(dp[i][j][c], dp'[i][j][k][1]\) の順で求めていきます。

ここで、\(dp'[i_0][j_0][k][l]\) を求めようとする時点で、任意の\(i_0\leq j\leq j_0-1\)について\(dp'[i_0][j][k][l]\)、および \(i_0<i\leq j\leq N\) について \(dp[i][j][c]\) が求まっていることに注意します。
\(dp'[i][j][k][l]\)の定め方から、値は \(\displaystyle\min_{i_0\leq m\leq j_0-1} dp'[i_0][m][k][l-1]+dp[m+1][j_0][A_{k,l}]\) で求める事ができます。ここで、各操作において\(|C_k|=1\)であることから、\(A_{k,l}\)が \(T_iT_{i+1}\ldots T_j\)の後ろから何文字分に置き換えられたかというのがちゃんと定まるという事を用いています。

次に、\(dp[i][j][c], dp'[i][j][k][1]\) についてです。
\(dp[i][j][c]\) は\(i=j\)かつ\(T_i=c\)ならば\(dp[i][j][c]=1\), そうでないとき\(C_k=c\) であるような \(k\) について、\(\displaystyle\min_{C_k=c} (dp'[i][j][k][|A_k|]+1)\) で求まります。

\(|A_k|>1\)のものについてはすでに求まっているため、これらは
\(dp[i][j][c]=\min (M[i][j][c], dp[i][j][d_{c,1}]+1, dp[i][j][d_{c,2}]+1,\ldots, dp[i][j][d_{c,k_c}]+1)\) として書くことができます。
ここで、\(M[i][j][c]=\displaystyle\min_{C_k=c, |A_k|>1} (dp'[i][j][k][|A_k|]+1)\) であり、\(\{d_{c,m}\}\)は\(C_k=c, |A_k|=1\) であるような\(k\)についての\(A_k\)の集合の要素です。

この部分についてはダイクストラ法を用いて解くことができます。
仮想頂点 \(V\) から頂点 \(c\) に対してコスト \(M[i][j][c]\) の辺を張ります。さらに、頂点 \(d_{c,m}\) から 頂点 \(c\) に向けてコスト \(1\) の辺を張ります。このときの頂点 \(V\) から各頂点への最小コストが\(dp[i][j][c]\)の値となります。

\(dp'[i][j][k][1]\)については、\(dp'[i][j][k][1]=dp[i][j][A_{k,1}]\)で定まります。

あとは、\(dp'[1][N][k][A_k]\) を求めたのと同様にして\(S\)から\(T\) を作るのに必要な最小コストを計算することができます。
例えば、\(i=1\) のループの時のみ \(A_{k+1}=S\), \(C_{k+1}=*\) (どのアルファベットとも異なる文字)として、追加してあげればよいです。

さて、計算量について、各 \(i,j\) について\(dp'[i][j][k][l]\)を求めるのに \(O(KN\max(|A_i|))\), その後に\(O((K+L)\log L)\) (ただし, アルファベットの文字数を\(L\)とした )よって, 全体計算量は \(O(N^3K\max(|A_i|)+N^2(K+L)\log L)\)ですが, \(N\leq 50\), \(K\leq 50\), \(\max(|A_i|)\leq 50\), \(L\leq 26\) であることから\(50^5\simeq 3\cdot 10^8\) で抑えられ, 実際の計算では (実装方針によりますが) \(\frac{1}{12}\sim\frac{1}{6}\) 程度の係数が付く事から十分間に合います。
よって、この問題を解くことができました。

なお、実現可能な場合は必要な操作回数は高々 \((L-1)(1+2+\cdots +N)+(N-1)<32000\) 回程度で抑えられるため、int型による計算で十分です。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
