
		公式
		
			
				E - Mex and Update 解説
			
			by physics0523
			
		
		
		
		
			\(\rm{mex}\) の重要な性質として、長さ \(N\) の非負整数列の \(\rm{mex}\) は \(0\) 以上 \(N\) 以下です。
証明: 数列の長さは \(N\) ですが、 \(0\) 以上 \(N\) 以下の整数は \(N+1\) 個存在します。 このことから、 \(0\) 以上 \(N\) 以下の整数のうち含まれないものが少なくともひとつ存在することが分かります。

このことから、数列 \(A\) のうち \(N+1\) 以上のものは無視していい ( 「全て \(N+1\) であると取り扱う」「処理を行わない」などの方法で対処することができます ) ことが分かります。

クエリを処理していく段階で、 \(\rm{bk}\)\([i] = \) ( \(A\) 中に含まれる \(i\) の個数 ) を常に保持していくことを考えます。見つけるべきは \(\rm{bk}\)\([k]=0\) なる最小の \(k\) です。

これは、以下の手続きで発見できます。


まず、「整数を追加する」「指定した整数を削除する」「最小値を取り出す」ことができるデータ構造 \(s\) を用意する。 ( 例えば、C++で set を使ったり、 ACL の segtree の max_right を応用したりして実現できます。 )
次に、 \(\rm{bk}\) の初期値を計算する。


このとき、 \(\rm{bk}\)\([k]=0\) なる \(k\) を全て求め、 \(s\) に入れる。

各クエリの処理は以下の手順で行う。


まず、更新前の \(A_{i_k}\) について、 \(\rm{bk}\)\([A_{i_K}]\) から \(1\) 減算する。


このとき、\(\rm{bk}\)\([A_{i_K}]\) が \(0\) となれば、 \(s\) に \(A_{i_K}\) を追加する。

\(A_{i_k}\) を \(x_k\) に更新する。
更新後の \(A_{i_k}\) について、 \(\rm{bk}\)\([A_{i_K}]\) に \(1\) 加算する。


このとき、\(\rm{bk}\)\([A_{i_K}]\) が加算前に \(0\) であったなら、 \(s\) から \(A_{i_K}\) を削除する。

この時点での \(s\) に含まれる最小値が、このクエリまでの処理を終えた時点での答えになる。



実装例1 (C++):



実装例2 (C++):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
