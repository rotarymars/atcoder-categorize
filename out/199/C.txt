
		公式
		
			
				C - IPFL 解説
			
			by QCFium
			
		
		
		
		
			クエリを問題文の通りに処理すると、(例えば全て \(T_i = 2\) の場合に) 計算量が \(\Theta(QN)\) となってしまい実行時間制限に間に合いません。
そのため、\(T_i = 2\) の場合を高速に処理しなければなりません。
今前半 \(N\) 文字と後半 \(N\) 文字が反転されているかを表す変数 \(t\) を持っておきます。(最初 \(t\) は偽です)
\(T_i = 2\) のクエリのときは \(t\) の真偽を反転するだけで済みます。
\(T_i = 1\) のクエリのとき、\(t\) が偽ならそのまま \(A_i\) 文字目と \(B_i\) 文字目を入れ替えればよいです。
\(t\) が真のとき、データ上の \(S\) は実際の \(S\) と比べて前半 \(N\) 文字と後半 \(N\) 文字が反転されています。実際の \(S\) の\(x\) 文字目は、\(x \le N\) のときデータ上の \(S\) では \(x + N\) 文字目に対応し、\(x \gt N\) のときはデータ上の \(S\) の \(x - N\) 文字目に対応します。
よって、\(A_i, B_i\) をこのように変換してからデータ上の \(S\) で文字の交換を行えばよいです。

全てのクエリを処理し終わった後、最後に \(t\) が真なら \(S\) の前半 \(N\) 文字と後半 \(N\) 文字を反転してから出力し、偽なら \(S\) をそのまま出力すればよいです。
この解法の計算量は \(O(N + Q)\) となるので、実行時間制限にも十分間に合います。

		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
