1. 問題概要
2. アルゴリズム

2014/11/22

©AtCoder Inc. All rights reserved.

26


• どういう問題？
• 非常に有名な「ナップサック問題」の亜種です
– 商品がN個、重さWまで持てる。
– 各商品の重さA[i]と、価値B[i]が与えられる
– 価値を最大化しなさい

• 今回は、それに加えて、「商品の個数」が制約に加
わっている

2014/11/22


• 深さ優先探索で解ける？
– 今回は、C問題に合わせると、
• N個の商品について、「選ぶ」「選ばない」を選ぶ必要があります。
• XORではなく価値の和を最大化したいです。
• いくつかの制約があります

– みたいな問題になるため、似たような深さ優先探索で、答
えを求めることは可能です。
• ただし、制限時間内に終わるわけではない！

– 計算量を考えよう！
• 選択肢は「選ぶ」「選ばない」の2つ
• 商品はN個、つまり50個以下
– 2の50乗は10の15乗程度だが、これは組み合わせが多過ぎる

2014/11/22


• では、どうするか？
– 全部調べるのはなんとなくもったいない
– 計算を上手く纏められると嬉しい。
– そこで出てくるのが「動的計画法！」

2014/11/22


• 動的計画法って？
– ある状態に対して、「すでに訪れたか」や「最大値」「最小
値」を計算することで、無駄に計算をしないこと！

– 状態って何？
• 「今持ってる価値」とか「何個目まで調べた」とか「今選んだスク
ショの合計の幅」とか、そのような、探索をする上で必要な情報！

2014/11/22


• さっきと同じ感じで、深さ優先探索のイメージをして
みよう！
– 自分が書くならこんな感じ
• Int dfs(int useW, int useNum, int now) { 以下略
– useWは、「今まで選んだスクショの合計幅」
– useNumは、「今まで選んだスクショの数」
– Nowは、「今選ぶかどうか調べたいスクショが何枚目か」
» これに対して、dfs(0,0,0)みたいな感じで呼び出したい
» で、最大値が返ってくると嬉しい

– これで動いたら嬉しい！
• でも実際は間に合わない

2014/11/22


• どうすれば良いか？
– 解法１：メモ化再帰を使う
• メモ化再帰って？
– 深さ優先探索で書いた時に、同じ計算を省略する！

– 解法２：動的計画法を使う
» っていっても、メモ化再帰も動的計画法の一種ですが

• 「幅」「使った枚数」「何枚目まで見たか」に対して、価値の最大値
を計算する
– 再帰ではなく、ボトムアップで計算する！

2014/11/22


• 解法１：メモ化再帰を使う
– どう計算を省略するの？
• 要するに、同じ計算をしなければ良い
• 結果メモ用配列dp[W][N][N]を用意する
• Int dfs(int useW, int useNum, int now)とか書いたとする
– もしdp[useW][useNum][now]に既に数が入っていたら、その数を返
す
– 入っていなければ普通に計算をし、returnするときに、
dp[useW][useNum][now]に、returnする数を入れる
» こうすることにより、2回目から計算しなくて良くなる！

– 計算量は？
• 同じ計算をしなくなったので、useW, useNum, nowの組み合わせ
が何通りあるか調べれば良い
– これはそれぞれW,N,Nであり、それに対して2択の選択肢
– 5000万くらい！よってギリギリ間に合う！
2014/11/22


• 解法2：動的計画法を使う！
– dp[i][j][k]に、k番目まで調べた時の、幅合計i、使用枚数j
の最大値を入れるとする
– これは、dp[i][j][k-1]か、dp[i-A[k-1]][j-1][k-1]+B[k-1]のどち
らかしかありえない！
• なぜか？
• K番目まで調べて、幅i、枚数jが最大になる、ということは、K番目
のスクショを選んで最大になったか、選ばず最大になったか、どち
らかしかない
– K番目を使わない場合は、dp[i][j][k-1]
– K番目を使う場合は、使う前がdp[i-A[k-1]][j-1][k-1]であり、そこにB[k1]を足すことで、求めることが出来る！！

2014/11/22


• 解法3：動的計画法を使う！工夫する版！
– 解法2のkは実は省略できる
• K番目を使わない場合→そのまま
• K番目を使う場合→dp[i][j] = dp[i-A[k-1]][j-1]

– みたいな感じで、同じメモリ上で回すことが出来る
– ただし、この場合、「同じスクショを２回以上使わない工
夫」をする必要がある。
• 具体的には、ループの向きを逆にすると良い！

• 逆にすれば、「直前に足したのをまた足してしまう」ということがな
くなる

– 詳しくは生放送で実装の時に説明するよ！！
2014/11/22


