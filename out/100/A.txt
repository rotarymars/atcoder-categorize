
2321

3656

150

0:40

0ms

19 bytes

答えは、 𝑋 ≤ 8 かつ 𝑌 ≤ 8 のとき答えは “Yay!” となり、それ以外のとき答えは “:(“ となります。
まず、同じ人が取るケーキが隣り合ってはいけないので、16 ÷ 2 = 8 個を超えて置くことはできませ
ん。つまり、どちらかが 9 以上のとき食べたい数のケーキを食べることができないことが示せます。
また、𝑋 ≤ 8, 𝑌 ≤ 8 のとき、E869120 君が時計回りで 1, 3, 5, 7, 9, 11, 13, 15 番目の中か
ら、square1001 君が時計回りで 2, 4, 6, 8, 10, 12, 14, 16 番目の中から選ぶと、食べたい数
のケーキを、取り方の条件を満たしながら食べることができます。

これが分かれば、if 文などを用いて条件分岐をするだけです。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2663851

まず、以下の簡単な問題を考えてみましょう。
N 個のケーキがあり、綺麗さ・おいしさ・人気度が決まっている。
M 個のケーキを選ぶ。
（綺麗さの合計） + （おいしさの合計） + （人気度の合計） の最大値を求めよ。

この問題は簡単に解くことができます。ケーキ 𝑖 の綺麗さを 𝑥𝑖 、おいしさを 𝑦𝑖 、人気度を 𝑧𝑖 とすると、
求める値が (𝑥𝑖 + 𝑦𝑖 + 𝑧𝑖 ) の合計になるので、(𝑥𝑖 + 𝑦𝑖 + 𝑧𝑖 ) の値の大きい順に M 個取るという解法
が通用します。
しかし、本来の問題は、（綺麗さの合計の絶対値）+（おいしさの合計の絶対値）＋（人気度の
合計の絶対値）を最大化する問題でした。
すなわち、いくつかの要素の合計を負にする、という手も存在します。
ですので、綺麗さ・おいしさ・人気度のそれぞれの要素について、「正の方向に最大化する」 「負の方向
に最大化する」 のどちらを選ぶか、ということを考えると分かりやすいです。要素は 3 つあるので、23 = 8
通り全探索します。
例えば、綺麗さ・おいしさを正の方向に最大化、人気度を負の方向に最大化したい場合、𝑥𝑖 + 𝑦𝑖 −
𝑧𝑖 の大きい順にソートして、上から M 個のケーキを選ぶと良いです。
答えは全探索した 8 通りの中で最も良い解となります。全探索はビット演算などを用いると簡単にな
ります。計算量は 𝑂(𝑁 𝑙𝑜𝑔 𝑁) ∗ 8 = 𝑂(𝑁 𝑙𝑜𝑔 𝑁) となります。
また、この問題は実は 𝑂(𝑁) で解くことができます。長さ N の数列をソートして M 番目に大きい値
A を最悪計算量 𝑂(𝑁) で求めるアルゴリズムは このリンク に書かれており、値 A が求まった後は求め
た値より大きい値の合計を計算すれば良いので、この問題の最悪計算量は 𝑂(𝑁) となります。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2670489

Overall Analysis / Review
Problem

Corrects

Submissions

Difficulty*

First AC

Fastest

Shortest


2321

3656

150

0:40

0ms

19 bytes

