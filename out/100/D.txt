

ã¾ãšã€ä»¥ä¸‹ã®ç°¡å˜ãªå•é¡Œã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚
N å€‹ã®ã‚±ãƒ¼ã‚­ãŒã‚ã‚Šã€ç¶ºéº—ã•ãƒ»ãŠã„ã—ã•ãƒ»äººæ°—åº¦ãŒæ±ºã¾ã£ã¦ã„ã‚‹ã€‚
M å€‹ã®ã‚±ãƒ¼ã‚­ã‚’é¸ã¶ã€‚
ï¼ˆç¶ºéº—ã•ã®åˆè¨ˆï¼‰ + ï¼ˆãŠã„ã—ã•ã®åˆè¨ˆï¼‰ + ï¼ˆäººæ°—åº¦ã®åˆè¨ˆï¼‰ ã®æœ€å¤§å€¤ã‚’æ±‚ã‚ã‚ˆã€‚

ã“ã®å•é¡Œã¯ç°¡å˜ã«è§£ãã“ã¨ãŒã§ãã¾ã™ã€‚ã‚±ãƒ¼ã‚­ ğ‘– ã®ç¶ºéº—ã•ã‚’ ğ‘¥ğ‘– ã€ãŠã„ã—ã•ã‚’ ğ‘¦ğ‘– ã€äººæ°—åº¦ã‚’ ğ‘§ğ‘– ã¨ã™ã‚‹ã¨ã€
æ±‚ã‚ã‚‹å€¤ãŒ (ğ‘¥ğ‘– + ğ‘¦ğ‘– + ğ‘§ğ‘– ) ã®åˆè¨ˆã«ãªã‚‹ã®ã§ã€(ğ‘¥ğ‘– + ğ‘¦ğ‘– + ğ‘§ğ‘– ) ã®å€¤ã®å¤§ãã„é †ã« M å€‹å–ã‚‹ã¨ã„ã†è§£æ³•
ãŒé€šç”¨ã—ã¾ã™ã€‚
ã—ã‹ã—ã€æœ¬æ¥ã®å•é¡Œã¯ã€ï¼ˆç¶ºéº—ã•ã®åˆè¨ˆã®çµ¶å¯¾å€¤ï¼‰+ï¼ˆãŠã„ã—ã•ã®åˆè¨ˆã®çµ¶å¯¾å€¤ï¼‰ï¼‹ï¼ˆäººæ°—åº¦ã®
åˆè¨ˆã®çµ¶å¯¾å€¤ï¼‰ã‚’æœ€å¤§åŒ–ã™ã‚‹å•é¡Œã§ã—ãŸã€‚
ã™ãªã‚ã¡ã€ã„ãã¤ã‹ã®è¦ç´ ã®åˆè¨ˆã‚’è² ã«ã™ã‚‹ã€ã¨ã„ã†æ‰‹ã‚‚å­˜åœ¨ã—ã¾ã™ã€‚
ã§ã™ã®ã§ã€ç¶ºéº—ã•ãƒ»ãŠã„ã—ã•ãƒ»äººæ°—åº¦ã®ãã‚Œãã‚Œã®è¦ç´ ã«ã¤ã„ã¦ã€ã€Œæ­£ã®æ–¹å‘ã«æœ€å¤§åŒ–ã™ã‚‹ã€ ã€Œè² ã®æ–¹å‘
ã«æœ€å¤§åŒ–ã™ã‚‹ã€ ã®ã©ã¡ã‚‰ã‚’é¸ã¶ã‹ã€ã¨ã„ã†ã“ã¨ã‚’è€ƒãˆã‚‹ã¨åˆ†ã‹ã‚Šã‚„ã™ã„ã§ã™ã€‚è¦ç´ ã¯ 3 ã¤ã‚ã‚‹ã®ã§ã€23 = 8
é€šã‚Šå…¨æ¢ç´¢ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€ç¶ºéº—ã•ãƒ»ãŠã„ã—ã•ã‚’æ­£ã®æ–¹å‘ã«æœ€å¤§åŒ–ã€äººæ°—åº¦ã‚’è² ã®æ–¹å‘ã«æœ€å¤§åŒ–ã—ãŸã„å ´åˆã€ğ‘¥ğ‘– + ğ‘¦ğ‘– âˆ’
ğ‘§ğ‘– ã®å¤§ãã„é †ã«ã‚½ãƒ¼ãƒˆã—ã¦ã€ä¸Šã‹ã‚‰ M å€‹ã®ã‚±ãƒ¼ã‚­ã‚’é¸ã¶ã¨è‰¯ã„ã§ã™ã€‚
ç­”ãˆã¯å…¨æ¢ç´¢ã—ãŸ 8 é€šã‚Šã®ä¸­ã§æœ€ã‚‚è‰¯ã„è§£ã¨ãªã‚Šã¾ã™ã€‚å…¨æ¢ç´¢ã¯ãƒ“ãƒƒãƒˆæ¼”ç®—ãªã©ã‚’ç”¨ã„ã‚‹ã¨ç°¡å˜ã«ãª
ã‚Šã¾ã™ã€‚è¨ˆç®—é‡ã¯ ğ‘‚(ğ‘ ğ‘™ğ‘œğ‘” ğ‘) âˆ— 8 = ğ‘‚(ğ‘ ğ‘™ğ‘œğ‘” ğ‘) ã¨ãªã‚Šã¾ã™ã€‚
ã¾ãŸã€ã“ã®å•é¡Œã¯å®Ÿã¯ ğ‘‚(ğ‘) ã§è§£ãã“ã¨ãŒã§ãã¾ã™ã€‚é•·ã• N ã®æ•°åˆ—ã‚’ã‚½ãƒ¼ãƒˆã—ã¦ M ç•ªç›®ã«å¤§ãã„å€¤
A ã‚’æœ€æ‚ªè¨ˆç®—é‡ ğ‘‚(ğ‘) ã§æ±‚ã‚ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¯ ã“ã®ãƒªãƒ³ã‚¯ ã«æ›¸ã‹ã‚Œã¦ãŠã‚Šã€å€¤ A ãŒæ±‚ã¾ã£ãŸå¾Œã¯æ±‚ã‚
ãŸå€¤ã‚ˆã‚Šå¤§ãã„å€¤ã®åˆè¨ˆã‚’è¨ˆç®—ã™ã‚Œã°è‰¯ã„ã®ã§ã€ã“ã®å•é¡Œã®æœ€æ‚ªè¨ˆç®—é‡ã¯ ğ‘‚(ğ‘) ã¨ãªã‚Šã¾ã™ã€‚
ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ï¼š https://beta.atcoder.jp/contests/abc100/submissions/2670489

Overall Analysis / Review
Problem

Corrects

Submissions

Difficulty*

First AC

Fastest

Shortest


574

1636

450

5:48

1ms

138 bytes

â€»Expected difficulty is a score in this problemâ€™s difficulty. Itâ€™s only a guess from a formula.
Thank you for everyone to participating the contest or seeing this editorial! This
contest is exactly 100th ABC, so we wrote a new thing, â€œanalysis / reviewâ€.
Since this contest is an anniversary, some problemsâ€™ theme was â€œcakeâ€, which
is commonly eaten on birthdays (at least in Japan).
For example, problem A. This was about E869120 and square1001â€™s 16th
birthday, but there was a hidden intent to celebrate this ABC 100 anniversary. Or
did you make a guess correctly?
And also, in this contest, many â€œmultiple of 100â€ were appeared. For example,
the constraints of problem D was ğ‘ â‰¤ 10000 = 1002 and ğ‘ğ‘– â‰¤ 1010 = 1005 . And the
problem Bâ€™s â€œthe number of times that can be divided by 100â€ is derived from the
ABC â€œ100â€. Also, there are many 10â€™s because square root of 100 is exactly 10.
Anyway, thanks for reading the first page of English editorial. Please enjoy the
main body of this editorial :)
The main body of this editorial starts from the next page.

Problem Aï¼šHappy Birthday!
First, consider the case of ğ‘‹ â‰¤ 8 and ğ‘Œ â‰¤ 8 (both
wants no more than 8 pieces of cakes). In this case, if you
only allow E869120 taking ğ‘‹ pieces in red area and
square1001 taking ğ‘Œ pieces in blue area, it will satisfy the
condition (no two adjacent cakes are for same person).
Therefore, the answer for this case is â€œYay!â€.
Second, if one person wants to take more than 8 cakes, it will definitely not satisfy the
condition, so the answer for this case is â€œ:(â€œ.
If you realize this, remaining is only some implementation. The implementation of this
problem is as easy as a piece of cake. You can use if-else statement to branch two
conditions.
Sample Code (C++)ï¼š https://beta.atcoder.jp/contests/abc100/submissions/2663851

Problem Bï¼šRingoâ€™s Favorite Numbers
There are many possible solutions in this problem. This time, we will explain two
representative solutions.
Approach 1ï¼šSearch Everything
Consider this sub-problem: â€œYou are given an integer ğ‘¥ . How many times can ğ‘¥ be
divided by 100?â€. This can be solved by simulation and it works very fast.
If the answer is ğ¾, we should solve this sub-problem for ğ‘¥ = 1,2,3, â€¦ , ğ¾. Since ğ¾ is no
more than 1010000 (when ğ· = 2, ğ‘ = 100), you can write a program which is much faster
than execution time limit.
Sample Code (C++)ï¼š https://beta.atcoder.jp/contests/abc100/submissions/2669995
Approach 2ï¼šâ€Pencil and Paperâ€ Approach
Actually, you donâ€™t have to do brute-forcing (searching all possible answer). Actually, this
problem can be solved by pencil and paper (if ğ·, ğ‘ is fixed).
Let ğ‘ = 100ğ· . The number which can be divided by 100 exactly ğ· times is following:
ğ‘, 2ğ‘, 3ğ‘, 4ğ‘, â€¦ , 99ğ‘, 101ğ‘, 102ğ‘, 103ğ‘, â€¦ , 199ğ‘, 201ğ‘, 202ğ‘, 203ğ‘, â€¦ , 299ğ‘, 301ğ‘, â€¦
This means, only ğ‘š Ã— 100ğ· (ğ‘š is not a multiple of 100) can be divided by 100 exactly
ğ· times. Letâ€™s think about the solution based on this property.
Let ğ‘ the quotient of ğ‘ âˆ’ 1 divided by 99. The answer of this problem will be between
(100ğ‘ + 1) Ã— 100ğ· and (100ğ‘ + 99) Ã— 100ğ· . Also, there are 99ğ‘ numbers at most
100ğ‘ Ã— 100ğ· and can be divided by 100 exactly ğ· times. This means the answer will be
ranked ğ‘ âˆ’ 99ğ‘ from smallest value which we confined the range of the answer a while
ago. Therefore, the answer will be (100ğ‘ + ğ‘ âˆ’ 99ğ‘) Ã— 100ğ· .
ğ‘âˆ’1

Simplifying this, the answer will be (ğ‘ âˆ’ ğ‘) Ã— 100ğ· = (ğ‘ âˆ’ âŒŠ

99

âŒ‹) Ã— 100ğ· .

Approach 2+Î±ï¼šâ€Crafty solutionâ€ using Nâ‰¤100
Let ğ‘ = 100ğ· . Seeing Approach 2, the first 100 numbers which can be divided by 100
exactly ğ· times are ğ‘, 2ğ‘, 3ğ‘, 4ğ‘, â€¦ , 97ğ‘, 98ğ‘, 99ğ‘, 101ğ‘. Therefore, assuming ğ‘ â‰¤ 100,
the answer will be ğ‘ğ‘ = ğ‘ Ã— 100ğ· if ğ‘ â‰¤ 99 otherwise 101ğ‘ = 101 Ã— 100ğ· .
Sample Code (C++)ï¼š https://beta.atcoder.jp/contests/abc100/submissions/2663837

Problem C: *3 or /2
Letâ€™s see the characteristics of â€œ*3â€ or â€œ/2â€. You can â€œmultiply ğ‘ğ‘– by 3â€ unlimited time, but
you cannot â€œdivide ğ‘ğ‘– by 2â€, because you cannot choose this operation if ğ‘ğ‘– is an odd
number.
So, the optimal solution seems like as follows:
â—† For each operation, divide exactly 1 number which is an even number, and multiple
other numbers.
Anyway, how many times will you divide?
Let ğ‘“(ğ‘¥) be â€œthe number of times that ğ‘¥ can be divided by 2â€. For example, ğ‘“(8) = 3,
ğ‘“(244) = 2 and ğ‘“(100) = 2.
If you choose â€œmultiple ğ‘ğ‘– by 3â€, ğ‘“(ğ‘ğ‘– ) should always be unchanged. Otherwise (if you
choose â€œdivide ğ‘ğ‘– by 2â€), ğ‘“(ğ‘ğ‘– ) should always decrease by 1.
Finally, if all ğ‘“(ğ‘ğ‘– ) became zero (This means that all number is odd), you cannot do
operation anymore.
So, the maximum number of operation is ğ‘“(ğ‘1 ) + ğ‘“(ğ‘2 ) + â‹¯ + ğ‘“(ğ‘ğ‘ ). Since you can
determine ğ‘“(ğ‘¥) with ğ‘‚(ğ‘™ğ‘œğ‘” ğ‘¥) complexity, the complexity of this algorithm is
ğ‘‚(ğ‘ ğ‘™ğ‘œğ‘” ğ‘šğ‘ğ‘¥ ğ‘ğ‘– ).
Sample Code: https://beta.atcoder.jp/contests/abc100/submissions/2670458
Bonus: You can solve the problem with complexity ğ‘‚(ğ‘ log log max ğ‘ğ‘– ). Because, if you use
binary-search by the value of ğ‘“(ğ‘¥), you can determine ğ‘“(ğ‘¥) with complexity ğ‘‚(log log ğ‘¥).

Problem Dï¼šPatisserie ABC
First, letâ€™s think about this easy sub-problem:
There are N cakes, which the value of beauty, tastiness, and popularity.
You will choose M cakes.
Find the maximum possible value of (sum of beauty) + (sum of tastiness) + (sum of

popularity).
This sub-problem can be solved easily. If cake ğ‘–â€™s beauty is ğ‘¥ğ‘– , tastiness is ğ‘¦ğ‘– , and
popularity is ğ‘§ğ‘– , the answer will be sum of (ğ‘¥ğ‘˜ + ğ‘¦ğ‘˜ + ğ‘§ğ‘˜ ) when ğ‘˜ is the chosen cakes.
Therefore, choosing ğ‘€ cakes from higher (ğ‘¥ğ‘– + ğ‘¦ğ‘– + ğ‘§ğ‘– ) is the optimal choice.
But the original problem is to maximize (absolute value of sum of beauty) + (absolute
value of sum of tastiness) + (absolute value of sum of popularity). So, thereâ€™s also a way to
make some parametersâ€™ sum to negative.
Thus, you can understand easily, if you think about â€œmaximizing force toward positive
directionâ€ or â€œmaximizing force toward negative directionâ€ for each parameter: beauty,
tastiness, and popularity. Since there are three parameters, you can brute-force 23 = 8
ways.
For example, if you want sum of beauty and sum of tastiness to maximize force toward
positive, and want sum of popularity to maximize force toward negative, choosing ğ‘€ cakes
from higher (ğ‘¥ğ‘– + ğ‘¦ğ‘– âˆ’ ğ‘§ğ‘– ) is the optimal choice.
The answer will be the maximum value among 23 = 8 ways. It is possible to use
recursion for brute-forcing, but using â€œbrute-force with bit operationsâ€ will make easier
implementation. Supposing that you sort a length-ğ‘› array in ğ‘‚(ğ‘› log ğ‘›), the time complexity
will be ğ‘‚(ğ‘ log ğ‘) Ã— 8 = ğ‘‚(ğ‘ log ğ‘).
Sample Code (C++)ï¼š https://beta.atcoder.jp/contests/abc100/submissions/2670489
Bonusï¼šThis problem can be solved in linear time. First, you can calculate ğ‘š-th biggest
value in linear time. The algorithm called "Median of medians" enables calculating median in
linear time, and then binary-searching the array, the ğ‘š-th biggest value can be calculated in
linear time. The sum of number from 1st to ğ‘š-th biggest value will be calculated by, simply,
â€œsumming up the value larger than ğ‘š-th biggest valueâ€, plus we need some adjustment.


