
1806

6710

280

1:40

0ms

22 bytes

答えは、 𝑋 ≤ 8 かつ 𝑌 ≤ 8 のとき答えは “Yay!” となり、それ以外のとき答えは “:(“ となります。
まず、同じ人が取るケーキが隣り合ってはいけないので、16 ÷ 2 = 8 個を超えて置くことはできませ
ん。つまり、どちらかが 9 以上のとき食べたい数のケーキを食べることができないことが示せます。
また、𝑋 ≤ 8, 𝑌 ≤ 8 のとき、E869120 君が時計回りで 1, 3, 5, 7, 9, 11, 13, 15 番目の中か
ら、square1001 君が時計回りで 2, 4, 6, 8, 10, 12, 14, 16 番目の中から選ぶと、食べたい数
のケーキを、取り方の条件を満たしながら食べることができます。

これが分かれば、if 文などを用いて条件分岐をするだけです。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2663851

この問題には、たくさんの解法があります。そのうち代表的な 2 通りの解法を説明します。
方針 1：「全探索」
「整数 𝑥 が与えられる。そのとき、𝑥 は 100 で何回割り切れるか？」 という問題を解くことを考えま
す。これは、𝑥 を 100 で割り切れないようになるまで割り続けることによって、解くことができます。
答えが 𝐾 の場合、𝑥 = 1,2,3, … , 𝐾 について先ほどの問題を解くことになります。先ほどの問題は十
分高速に動作し、𝐾 の値は高々 1010000 (𝐷 = 2, 𝑁 = 100 のとき) なので、実行時間制限に余
裕で間に合うプログラムを書くことができます。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2669995

方針 2：「条件に当てはまる数を列挙」
100 でちょうど 𝐷 回割り切れるような数は、 𝑎 = 100𝐷 として次のようになります：
𝑎, 2𝑎, 3𝑎, 4𝑎, … , 99𝑎, 101𝑎, 102𝑎, 103𝑎, … , 199𝑎, 201𝑎, 202𝑎, 203𝑎, … , 299𝑎, 301𝑎, …
すなわち、𝑚 × 100𝐷 (𝑚 は 100 の倍数ではない) と表される数だけが 100 でちょうど 𝐷 回割
り切れます。これをもとに解法を考えてみましょう。
𝑞 = (𝑁 − 1 を 99 で割った商) とします。そのとき、この問題の答えは (100𝑞 + 1) × 100𝐷 以上
(100𝑞 + 99) × 100𝐷 以下の値になります。また、100𝑞 × 100𝐷 以下に 「100 でちょうど 𝐷 回割り
切れるような数」 は 99𝑞 個あるので、先ほど答えを限定した範囲の中で 𝑁 − 99𝑞 番目になります。し
たがって、答えは (100𝑞 + 𝑁 − 99𝑞) × 100𝐷 になります。
𝑁−1

より簡略化すると、答えは (𝑁 − 𝑞) × 100𝐷 = (𝑁 − ⌊

99

⌋) × 100𝐷 になります。

方針 2+α：「ズルい解法：N≤100 までを利用して解く」
「方針 2」 の考察で、𝑎 = 100𝐷 として、100 でちょうど 𝐷 回割り切れるような数の最初 100 個
は 𝑎, 2𝑎, 3𝑎, 4𝑎, … , 97𝑎, 98𝑎, 99𝑎, 101𝑎 になります。
したがって、𝑁 ≤ 100 を仮定すると、𝑁 ≤ 99 のとき 𝑁𝑎 = 𝑁 × 100𝐷 が答えとなり、𝑁 = 100 のと
き 101𝑎 = 101 × 100𝐷 が答えになります。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2663837

まず、以下の簡単な問題を考えてみましょう。
N 個のケーキがあり、綺麗さ・おいしさ・人気度が決まっている。
M 個のケーキを選ぶ。
（綺麗さの合計） + （おいしさの合計） + （人気度の合計） の最大値を求めよ。

この問題は簡単に解くことができます。ケーキ 𝑖 の綺麗さを 𝑥𝑖 、おいしさを 𝑦𝑖 、人気度を 𝑧𝑖 とすると、
求める値が (𝑥𝑖 + 𝑦𝑖 + 𝑧𝑖 ) の合計になるので、(𝑥𝑖 + 𝑦𝑖 + 𝑧𝑖 ) の値の大きい順に M 個取るという解法
が通用します。
しかし、本来の問題は、（綺麗さの合計の絶対値）+（おいしさの合計の絶対値）＋（人気度の
合計の絶対値）を最大化する問題でした。
すなわち、いくつかの要素の合計を負にする、という手も存在します。
ですので、綺麗さ・おいしさ・人気度のそれぞれの要素について、「正の方向に最大化する」 「負の方向
に最大化する」 のどちらを選ぶか、ということを考えると分かりやすいです。要素は 3 つあるので、23 = 8
通り全探索します。
例えば、綺麗さ・おいしさを正の方向に最大化、人気度を負の方向に最大化したい場合、𝑥𝑖 + 𝑦𝑖 −
𝑧𝑖 の大きい順にソートして、上から M 個のケーキを選ぶと良いです。
答えは全探索した 8 通りの中で最も良い解となります。全探索はビット演算などを用いると簡単にな
ります。計算量は 𝑂(𝑁 𝑙𝑜𝑔 𝑁) ∗ 8 = 𝑂(𝑁 𝑙𝑜𝑔 𝑁) となります。
また、この問題は実は 𝑂(𝑁) で解くことができます。長さ N の数列をソートして M 番目に大きい値
A を最悪計算量 𝑂(𝑁) で求めるアルゴリズムは このリンク に書かれており、値 A が求まった後は求め
た値より大きい値の合計を計算すれば良いので、この問題の最悪計算量は 𝑂(𝑁) となります。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2670489

Overall Analysis / Review
Problem

Corrects

Submissions

Difficulty*

First AC

Fastest

Shortest


1806

6710

280

1:40

0ms

22 bytes

