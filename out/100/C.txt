
1887

2433

270

1:02

1ms

42 bytes

𝑁 ≤ 10000, 𝑎𝑖 ≤ 109 なので, 操作をたくさん行ったときに、最終的な値が 90000 桁近くなるケー
スがあります。これは、仮に最適な方法が分かっていたとしても、シミュレーションをするのには桁数が大きす
ぎるので、何か別の方法を考えなければなりません。
まず、「3 倍する」 操作を何回かやっておくことで、「2 で割る」 操作の回数が増えたり減ったりするで
しょうか？答えは No です。なぜなら、奇数を掛けて 2 で割れる回数が増えることはなく、整数を掛けて
2 で割れる回数が減ることがないからです。
したがって、「3 倍する」 操作はその後の操作回数に何ら影響を及ぼしません。すなわち、「3 倍する」
は 「何もしない」 という条件に置き換えることができます。よって、各操作は 「𝑁 個すべての数に対して、
その数を 「2 で割る」 または 「そのままにする」 のどちらかを選ぶが、全部そのままにすることはできない」
というように置き換えられます。
次に、各操作について考えてみましょう。「2 で割る」 ことによって残り操作回数は減りますが、「そのま
まにする」 は残り操作回数が減らないので、各操作で 「2 で割る」 個数を最小化、すなわち 「2 で割
る」 個数を 1 個にすることを考えます。したがって、1 回の操作で 「𝑁 個の数の中から 1 つ選び、こ
れを 2 で割る」 に置き換えることができます。
あとはウィニングランです。答えは (𝑎1 が 2 で割れる回数) + (𝑎2 が 2 で割れる回数) + … +
(𝑎𝑁 が 2 で割れる回数) となります。𝑥 が 2 で割れる回数は単純にシミュレーションしても計算量
𝑂(𝑙𝑜𝑔 𝑥) で求めることができるので、全体の計算量は 𝑂(𝑁 𝑙𝑜𝑔(𝑚𝑎𝑥 𝑎𝑖 )) になります。
おまけ：計算量 𝑂(𝑁 𝑙𝑜𝑔 𝑙𝑜𝑔 (𝑚𝑎𝑥 𝑎𝑖 )) で求める方法もあります。𝑥 が 2 で割れる回数を二分法で
求めることによって、この計算量を達成することができます。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2670458

まず、以下の簡単な問題を考えてみましょう。
N 個のケーキがあり、綺麗さ・おいしさ・人気度が決まっている。
M 個のケーキを選ぶ。
（綺麗さの合計） + （おいしさの合計） + （人気度の合計） の最大値を求めよ。

この問題は簡単に解くことができます。ケーキ 𝑖 の綺麗さを 𝑥𝑖 、おいしさを 𝑦𝑖 、人気度を 𝑧𝑖 とすると、
求める値が (𝑥𝑖 + 𝑦𝑖 + 𝑧𝑖 ) の合計になるので、(𝑥𝑖 + 𝑦𝑖 + 𝑧𝑖 ) の値の大きい順に M 個取るという解法
が通用します。
しかし、本来の問題は、（綺麗さの合計の絶対値）+（おいしさの合計の絶対値）＋（人気度の
合計の絶対値）を最大化する問題でした。
すなわち、いくつかの要素の合計を負にする、という手も存在します。
ですので、綺麗さ・おいしさ・人気度のそれぞれの要素について、「正の方向に最大化する」 「負の方向
に最大化する」 のどちらを選ぶか、ということを考えると分かりやすいです。要素は 3 つあるので、23 = 8
通り全探索します。
例えば、綺麗さ・おいしさを正の方向に最大化、人気度を負の方向に最大化したい場合、𝑥𝑖 + 𝑦𝑖 −
𝑧𝑖 の大きい順にソートして、上から M 個のケーキを選ぶと良いです。
答えは全探索した 8 通りの中で最も良い解となります。全探索はビット演算などを用いると簡単にな
ります。計算量は 𝑂(𝑁 𝑙𝑜𝑔 𝑁) ∗ 8 = 𝑂(𝑁 𝑙𝑜𝑔 𝑁) となります。
また、この問題は実は 𝑂(𝑁) で解くことができます。長さ N の数列をソートして M 番目に大きい値
A を最悪計算量 𝑂(𝑁) で求めるアルゴリズムは このリンク に書かれており、値 A が求まった後は求め
た値より大きい値の合計を計算すれば良いので、この問題の最悪計算量は 𝑂(𝑁) となります。
サンプルコード： https://beta.atcoder.jp/contests/abc100/submissions/2670489

Overall Analysis / Review
Problem

Corrects

Submissions

Difficulty*

First AC

Fastest

Shortest


1887

2433

270

1:02

1ms

42 bytes

