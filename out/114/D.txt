N = 100 のとき N ! = 93326215443944152681... (158 桁) です。これを直接取り扱っても不毛で、効率的
な枠組みで考える必要があります。
準備体操として、入出力例 2 の説明にある 32400 が確かに約数を 75 個持つことを確認しましょう。

32400 を素因数分解 (リンク先は Wikipedia の同名の記事) すると 32400 = 24 34 52 となります。よって
2a 3b 5c (0 ≤ a ≤ 4, 0 ≤ b ≤ 4, 0 ≤ c ≤ 2) という形で表せる数はすべて 32400 の約数で、他にはありません。
a の値は 0, 1, 2, 3, 4 の 5 通り、b の値も 5 通り、c の値は 3 通りで、約数は全部で 5 × 5 × 3 = 75 個です。
同じように考えると、3 つの異なる素数 p, q, r を使って p4 q 4 r2 と表せる数はすべて七五数です。ほかに、

p14 q 4 , p24 q 2 , p74 という「パターン」の数も約数を 15 × 5 = 25 × 3 = 75 個持ちます。75 = 3 × 5 × 5 を分
割することを考えると以上の 4 パターンがすべてで、これらをそれぞれ数えればよいです。
最も複雑な p4 q 4 r2 のパターンを考えます。まず 1, 2, . . . , N をそれぞれ素因数分解して合算すること
で N ! を素因数分解します*4 。素数 s に対して「N ! の素因数分解での s の指数」*5 を e(s) と書くと、

e(p) ≥ 4, e(q) ≥ 4, e(r) ≥ 2 が成立すれば p4 q 4 r2 は N ! の約数です。このような p, q, r の組合せの数を三重
*7
ループで数える*6 か、もう少し考えて数式で求めることもできます。Python3 での後者の例を示します。

1

N = int(input())

2

e = [0] * (N+1)

3

for i in range(2, N+1):

4

cur = i

5

for j in range(2, i+1):

6

while cur % j == 0:

7

e[j] += 1

8

cur //= j

9
10
11

def num(m):

# e の要素のうち m-1 以上のものの個数

return len(list(filter(lambda x: x >= m-1, e)))

12
13
14

print(num(75) + num(25) * (num(3) - 1) + num(15) * (num(5) - 1)
+ num(5) * (num(5) - 1) * (num(3) - 2) // 2)

*4 N 自体は 100 以下と小さいので、愚直に割り算を繰り返せば十分です。エラトステネスの篩などの効率的なアルゴリズムは不要
*5 例えば N = 4 のとき N ! = 24 = 23 3 なので e(2) = 3, e(3) = 1
*6 ただし、例えば 24 34 52 と 34 24 52 が同じ数であることに注意
*7 余談: ここでは 75 という具体的な値に注目して解きましたが、
「約数を x 個持つ数の個数」を x の小さい順に求めていく解法も

あります（動的計画法と呼ばれる手法です）。

4


