
2023/1/27

©AtCoder Inc. All rights reserved.

16


• 高橋君は、マス目 (i,j) から (i+1,j) または (i,j+1) に進
むことができます。
• 高橋君が (1,1) から (W,H) まで行く経路の個数
を 1,000,000,007 で割ったあまりを求めてください。
• 制約
– 1 ≦ W,H ≦ 100,000

2023/1/27

17


• 経路の数え方
– 探索を使う？
• 深さ優先探索
• 幅優先探索

– 確かに経路個数は数えられる
• でも時間が足りない！
• 50点の部分点は得られる

2023/1/27

18


• 経路の数え方
– 動的計画法？

2023/1/27

19


• 経路の数え方
– 各地点に辿り着く経路数をメモする
– 周りのマスから、次のマスへの経路数をメモする
– こうすると、計算するべき地点はW× H個しかない！
– これで100点
• 101点は取れない

– 実装は2次元配列などで！
DP[a,b] = DP[a-1,b]+DP[a,b-1];
DP[a,b] %= mod;

2023/1/27

20


• 数学的に計算しよう！
– 問題を読み替えると、「上にH-1回、右にW-1回移動する
組み合わせの個数」を求めれば良い。
– これは、(H+W-2)回移動する中から、H-1回移動する方法
を求めれば良い！
• これは、 ுାௐିଶ ுିଵ で求まる！
• つまり、(H+W-2)! / (H-1)!(W-1)!で求まる。

2023/1/27

21


• (H+W-2)! / (H-1)!(W-1)!の求め方
– 普通にforループを求めれば出来そう？
– 問題は、「 mod = 1,000,000,007 で割った余りを求めなさ
い」
• (H+W-2)!や(H-1)!(W-1)!は大きすぎて計算しきれない
• そこで、(H+W-2)!をmodで割ってあまりを計算してしまうと、普通
に割り算は出来ない！

– どうすればいいか？

2023/1/27

22


• 逆元を求めよう！
– M = 1,000,000,007は素数なので、mod Mでの割り算は、
掛け算に変換できる！
– フェルマーの小定理により、
• pが素数の時、 ௣ିଵ
ିଵ
• つまり、 ௣ିଶ
• これを利用して、Aで割りたい時は、AのM-2乗で掛ければ良い！
– 累乗 ௕ (mod p)の計算は、実はO(logb)で出来る！
» 例えば、32乗を計算したい時は、16乗を計算して、その2つをかける。
» 33乗を計算したい時は、32乗から1乗をかける。

– ぶっちゃけ初めての人は知らなくて当たり前なので、これを機会に
覚えよう！
2023/1/27

23


• 累乗

(mod p)の計算の仕方！
» 解りやすい計算方法を紹介するので、早いのは自分で調べよう！

• aのb乗をpで割った余りを計算する関数
» オーバーフローは無視して描いてます。

– calc(int a, int b, int p)について考える
• b==0の時、
– return 1;すれば良い。

• bが偶数の時、
– Int d = calc(a, b/2, p);
– return (d * d) % p; とすると、bが半分に出来る。

• bが奇数の時、
– return (a * calc(a, b-1, p)) % p; とすれば良い。

– 奇数の後は偶数が必ず呼ばれるので、2回に1回はbが半
分になる。よって計算量はO(logb)
2023/1/27

24

