
		公式
		
			
				G - Distance Queries on a Tree 解説
			
			by MMNMM
			
		
		
		
		
			この問題は、Euler Tour と呼ばれる技法を使って解くことができます。（Euler Tour の詳細についてはここでは解説しません。一言で述べると、根から深さ優先探索を行う際に訪れる辺を向きを含めて順に並べたもの（あるいは頂点を訪れる順に並べたもの）です。）

与えられた木の適当な頂点 \(r\) を根として根付き木とします。

頂点 \(u,v\) の距離を \(d(u,v)\) と書くと、根 \(r\) および \(u,v\) の最小共通祖先 \(\operatorname{lca}(u,v)\) について次の式が成り立ちます。

\[\begin{aligned}d(u,v)&=d(u,\operatorname{lca}(u,v))+d(\operatorname{lca}(u,v),v)\\&=(d(r,u)-d(r,\operatorname{lca}(u,v)))+(d(r,v)-d(r,\operatorname{lca}(u,v)))\\&=d(r,u)+d(r,v)-2d(r,\operatorname{lca}(u,v))\end{aligned}\]

よって、この問題は次の \(2\) 種類のクエリを高速に処理することで解くことができます。


頂点 \(u\) に対して、\(d(r,u)\) を求める。
頂点 \(u,v\) に対して、\(\operatorname{lca}(u,v)\) を求める。


前者は重みの更新があるので同じ \(u\) に対する結果が変わる場合があり、後者は木の形が変わらないので同じ \((u,v)\) に対する結果は変わりません。

Euler Tour を用いることで、それぞれ適当な列について次の種類のクエリを高速に処理すればよいことになります。前者と後者で必ずしも同じ列を管理するわけではないことに注意してください。


重みを更新する・頂点 \(u\) に対して \(d(r,u)\) を求める。


更新を行う辺 \(e\) に対して Euler Tour の \(+e,-e\) に対応する場所の重み \(+w,-w\) を変更する
頂点 \(u\) に対応する先頭からの区間の重みの合計を得る

頂点 \(u,v\) に対して、\(\operatorname{lca}(u,v)\) を求める。


頂点 \(u,v\) に対応する区間における最小値の index を得る



それぞれ Binary Indexed Tree やセグメント木、Sparse Table などを用いることで高速に処理することができます。

たとえば前者を Binary Indexed Tree 、後者をセグメント木で管理すると、空間計算量を \(O(N)\) 、時間計算量を \(O(N+Q\log N)\) とすることができます。

実装例は以下のようになります。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
