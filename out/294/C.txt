
		公式
		
			
				C - Merge Sequences 解説
			
			by MMNMM
			
		
		
		
		
			\(C=(C _ 1,C _ 2,\ldots,C _ {N+M})\) は、列を連結してソートすることで \(O((N+M)\log(N+M))\) 時間で求めることができます。
これで十分高速ですが、より高速に \(C\) を求めるアルゴリズムもあります。

ソート列をマージする高速なアルゴリズム（ \(O(N+M)\) 時間）

次のアルゴリズムを用いると \(C\) を \(O(N+M)\) 時間で求めることができます。


はじめ \(i=j=k=1\) として、\(i\leq N+M\) である限り次を繰り返す。


\(k>M\) であるか、\(j\leq N\) かつ \(A _ j\leq B _ k\) のとき、


\(C _ i=A _ j\) とし、\(i,j\) を \(1\) 増やす。

そうでないとき、


\(C _ i=B _ k\) とし、\(i,k\) を \(1\) 増やす。




C++ では、std::merge 関数でこれを行うことができます。


\(C\) が具体的に得られたら、（必要ならば適切な前計算ののち）\(C _ i\) の値から \(i\) を計算することが \(O(\log(N+M))\) 時間や expected \(O(1)\) 時間で可能です。
前者は \(C\) に対する二分探索や（平衡二分探索木などによる）連想配列、後者は（ハッシュマップによる）連想配列で実現できます。

よって、この問題を \(O((N+M)\log(N+M))\) 時間や expected \(O(N+M)\) 時間で解くことができました。

ソート列のマージの際に答えを計算したり、適切な情報と組にしてマージすることで worst \(O(N+M)\) 時間で解くこともできます。

実装例は以下のようになります。


python による解法





C++ による \(O((N+M)\log(N+M))\) 時間の解法





C++ による worst \(O(N+M)\) 時間の解法




		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
