
●

1 から N までのすべての整数を
一回ずつ紙に書いたとき
1 という数字は何回書かれるか?

●

N = 12 → 5
(1 2 3 4 5 6 7 8 9 10 11 12)

●

20点: 1 ≦ N ≦ 999
100点: 1 ≦ N < 109

●

1 から 999 くらいなら全部「書け」ます

●

整数を文字列に変換して問題 B と同じ要領で 1 を数える
（この方法は言語ごとにかなり異なるので
調べてください）

●

補足: AtCoder で部分点を狙う場合、「正解したいテストケース」
以外が入力されたらすぐに終了するようにすると結果が早く出ます
C++ なら #include <cassert> して assert(N <= 999); とか

●

10 億までだと全部「書く」のは 2 秒では厳しい
（合計で約 89 億桁、 1 分くらい必要?）

●

「10 には数字の 1 が何個含まれるか?」
「11 には?」「12 には?」という方針から変えよう

●

1 ≦ N ≦ 999999999: 各整数は 1 〜 9 桁

●

9 桁に満たない整数には先頭に 0 を付け足して
9 桁ということにして考えてみる
12345678 → 012345678, 1 → 000000001

●

ついでに、 000000001 から始まるよりは
000000000 から始まったほうがきれい。
1 から N の代わりに、 0 から N の整数について考えることにする
（答えは変わらない）

000000000

●

例として N = 2015 のケースを考える

●

先頭の「000000000」も含めて

000000001
:
000000009
000000010
000000011
:

数字の列が N + 1 = 2016 個ある

000000020
:
000000099
000000100
:
000002015: N

（左の方の 0 が無駄なようだが、
害はない）

000000000

●

000000001

まずは 1 の位に注目
01234567890123456789012…

:

長さ 10 の周期で同じパターンが続く

000000009
000000010
000000011
:
000000020
:
000000099
000000100

●

N = 2015 の場合、”0123456789”
というパターンが 2016 / 10 = 201 回
続き、最後にパターンの先頭から
2016 % 10 = 6 個の数字(“012345”)が並ぶ

:
000002015: N

→ 1 という数字は 201 + 1 = 202 個出現する

000000000

●

次に 10 の位に注目

000000001

“00000000001111111111222…999” という

:

長さ 100 の同じパターンが続く

000000009
000000010

●

000000011

N = 2015 の場合、パターンが 2016 / 100 = 20 回

:

続き、最後にパターンの先頭から
2016 % 100 = 16 個の数字

000000020

(“0000000000111111”)が並ぶ

:
000000099

→ 1 という数字は 10 * 20 + 6 = 206 個出現する

000000100
:
000002015: N

●

100 の位以降も同様に計算し、
1 億の位までのすべての位での出現数の総和が答え

●

あえて 省略
頑張って実装してください。
一つだけ補足:
今回のように 32bit 整数の上限 (21億+α) 付近の
数を扱う場合、 64bit 整数を使うと安全です。
(今回は 1 ≦ N < 109 なのでおそらく大丈夫ですが)


