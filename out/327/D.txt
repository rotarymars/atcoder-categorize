
		公式
		
			
				D - Good Tuple Problem 解説
			
			by  Nyaan
			
		
		
		
		
			グラフ理論の言葉に置き換えて考えます。\(N\) 頂点 \(M\) 辺のグラフがあって、\(i\) 番目の辺は頂点 \(A_i\) と頂点 \(B_i\) を結んでいるとします。
このとき、問題文の条件を満たすような数列 \(X\) が存在することは、次の条件と同値です。


以下の条件を満たすように各頂点に \(0\) か \(1\) を書きこむことができる。


辺で結ばれた頂点同士には異なる数字が書きこまれている。



このような条件によって定義されるグラフのことを 二部グラフ と呼びます。よって、この問題はグラフが二部グラフかを判定するアルゴリズムを実装すれば正解できます。

グラフが二部グラフであるかどうかの判定は深さ優先探索(DFS) などのグラフ探索アルゴリズムを利用して実装できます。具体的には、以下の手順で頂点に数字を書きこんでいけばよいです。


各頂点についての情報を配列 \(X\) に格納する。


\(X[v] = -1\) である場合は頂点は未訪問であることを、
\(X[v] = 0\) である場合は頂点に \(0\) が書きこまれていることを、
\(X[v] = 1\) である場合は頂点に \(1\) が書きこまれていることを意味する。

また、答えを管理するフラグ bipartite を用意して、はじめ true で初期化する。
\(v=1, 2, \dots, N\) について次の操作を行う。


\(X[v] \neq -1\) である場合は頂点 \(v\) は訪問済みなので何もしない。
\(X[v] = -1\) である場合は以下の操作を行う。


頂点 \(v\) に書きこむ数字を \(0\) と決め打つ。(つまり \(X[v] = 0\) とする)
その後、深さ優先探索を利用して、 \(v\) を含む連結成分に含まれる頂点に、隣り合う頂点が異なる数字となるように数字を書きこんでいく。
書きこんでいく途中で、辺で結ばれた頂点同士に同じ数字が書きこまれた状態になった場合は、グラフは二部グラフではないので bipartite = false とする。


全ての頂点を訪問し終えた段階での bipartite の真偽が答えとなる。


計算量は \(\mathrm{O}(N + M)\) で十分高速です。C++ による実装例は次の通りです。


実装例




		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
