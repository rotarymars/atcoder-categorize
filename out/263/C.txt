
		公式
		
			
				C - Monotonically Increasing 解説
			
			by PCTprobability
			
		
		
		
		
			\(S_{N,M}\) を長さ \(N\) かつ全ての要素が \(1\) 以上 \(M\) 以下の狭義単調増加である整数列の集合とします。

まず、\(N=1\) であるとき \(S_{N,M}=(\{1\},\{2\},\dots,\{M\})\) です。

以降、\(N \ge 2\) とします。
\(S_{N,M}\) に含まれる整数列の最後の項を全探索します。

もし最後の項が \(K\) であるならば始めの \(N-1\) 項としてあり得るものの集合は \(S_{N-1,K-1}\) に等しいです。ここで、\(N-1 \le K-1\) でなければならないことに注意してください。

より、\(K\) を全探索し \(S_{N-1,K-1}\) の要素に \(K\) を付け加えたものを \(S_{N,M}\) に加えることで \(S_{N,M}\) を求めることができます。

より、この問題を解くことができます。

また、別解法として C++ であれば \(0\) が \(N\) 個、\(1\) が \(M-N\) 個この順で並べられた vector を用意し、next_permutation で毎回 \(0\) である要素の index を出力することによっても解くことができます。こちらの解法の方が実装は短く済みます。

実装例(C++)



実装例(next_permutation,C++)



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
