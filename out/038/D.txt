1. 問題概要
2. 考察
3. アルゴリズム

2016/5/31

©AtCoder Inc. All rights reserved.

16

• 長方形がN個あり、横がhi[cm]と縦がwi[cm]と決まっている。
• 最大で何重の入れ子にできるか？

• 制約
– 1 ≦ N ≦ 105
– 0 ≦ hi, wi ≦ 105

2016/5/31

17


• 部分点解法:
– DPを考えてみよう！
– dp[i]:=i番目の箱を最も外側とするとき、最大で何重の入
れ子とできるか
– dp[i]:=max(dp[j])+1 ただし、i番目の箱はj番目の箱を入れ
ることができる
– これをメモ化再帰として実装すればOK
• ある箱は直接または間接的にその箱自身を含むことはできない
ため、DPの遷移で閉路が生じない

– O(N2)


• 満点解法
• hiがすべて互いに異なる場合をひとまず考えよう
– dp[i]:=max{dp[j]|hj<hi かつ wj<wj}+1 というDPの遷移だっ
た
• max{f(x) | 条件} というのは、条件を満たすようなxでのf(x)の最大
値という意味

– 箱をhiが昇順となるようにソートすると、
dp[i]:=max{dp[j] | j<i かつ wj<wi}+1
– よって、iを1からNまで増やしながらDPを求めていくことに
すると、wがより小さいもののうちの最大値が求まればOK


• wがある値以下という条件での最大値を高速に求め
るデータ構造が欲しい
– > BIT(Binary Indexed Tree, Fenwick Tree)が手軽かつ便利
– 解説は諸サイト・スライドに譲ることにします
• 蟻本にも載ってる！

• BITは区間の和を持つ方法が最も基本的だが、列で
1番目からk番目の最小値を求める操作と列の値の
更新の操作も行うことができる
– 今回はこの操作を使います


• BITで扱う列のi番目を最も外側の箱の横の長さがiと
なる入れ子の数の最大値とする
• query(i)で列のうちi番目まで最大値、update(i,a)を列
のi番目をaで更新、とすると、
以下のような感じ
for i from 1 to N
dp[i]:=bit.query(wi-1)+1
bit.update(wi, dp[i])
最終的に、dp[i]のうち最大値が答え
• BITの1回の更新/最小値クエリーはどちらもO(logN)
なので、O(NlogN)


• hiに同じ数があるとき…
– hiが同じ箱はwiの降順にソートするとそのままのコードで
うまくいく
• hが同じ箱はどれも互いに入れ子にならないので、hが同じもので
入れ子を作らないように並んでいて欲しい
• wiの降順に並べると、先にdpの値が計算された箱を含むような入
れ方はないため、hが同じ箱で入れ子になることがなく、正しい答
えが得られる

– その他に、hが同じ箱を計算している間はBITをupdateせ
ず、hが変わるとそこでupdateを全て行うという方法もある


