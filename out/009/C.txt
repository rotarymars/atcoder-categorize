辞書式順序ふたたび

問題
文字列 S を並び替えて文字列 T を作る。
ただし動いた文字の個数が K 以下でなければダメ。
そのような制限のもとで、辞書順最小の T は？
制限
1 ≦ N (S の文字数) ≦ 100
1≦K≦N

基本は、問題文にあったヒントのように実装
読んでない場合は http://abc009.contest.atcoder.jp/tasks/abc009̲3

ヒントの繰り返しですが、重要なのは
・最初のほうに小さいアルファベットを持ってくる
・あるアルファベットを持ってきたときに、
制限を満たせるかどうかを判定する
の 2 点です。

今回も擬似コードでイメージを掴みましょう:
!T

← “”
for i = 0 to N - 1
for c in (まだ使える文字を小さい順に)
!
if (T + c にして大丈夫なら)
T ← T + c
break

今回も擬似コードでイメージを掴みましょう:
!T

← “”
for i = 0 to N - 1
for c in (まだ使える文字を小さい順に)
!
if (T + c にして大丈夫なら)
T
←
T
+
c
!
break
括弧書きでごまかした部分をちゃんと考える！

T を先頭から 1 文字ずつ決めていくが、
その途中で「まだ使える文字」とは何か？
S = “program” で
T = “aro” と最初の 3 文字だけ決まっているとき

T を先頭から 1 文字ずつ決めていくが、
その途中で「まだ使える文字」とは何か？
S = “program” で
T = “aro” と最初の 3 文字だけ決まっているとき
p, g, m は T にまだ入ってないので使える

T を先頭から 1 文字ずつ決めていくが、
その途中で「まだ使える文字」とは何か？
S = “program” で
T = “aro” と最初の 3 文字だけ決まっているとき
p, g, m は T にまだ入ってないので使える
a, o は T に入っているのでもう使えない

T を先頭から 1 文字ずつ決めていくが、
その途中で「まだ使える文字」とは何か？
S = “program” で
T = “aro” と最初の 3 文字だけ決まっているとき
p, g, m は T にまだ入ってないので使える
a, o は T に入っているのでもう使えない
r は S に 2 回出てきており、
T には 1 回しか出てきていないのでまだ使える

T を先頭から 1 文字ずつ決めていくが、
4 文字目の候補は p, g, m, r の 4 通り！
その途中で「まだ使える文字」とは何か？
S = “program” で
T = “aro” と最初の 3 文字だけ決まっているとき
p, g, m は T にまだ入ってないので使える
a, o は T に入っているのでもう使えない
r は S に 2 回出てきており、
T には 1 回しか出てきていないのでまだ使える

つまり、T の次の文字を c にしてしまった結果、
このあとどう頑張っても動いた文字の個数が K を
超えてしまう……、ということにならないだろうか？

つまり、T の次の文字を c にしてしまった結果、
このあとどう頑張っても動いた文字の個数が K を
超えてしまう……、ということにならないだろうか？
↓
残りの部分でできるだけ頑張って、
動いた文字が少なくなるようにしてみる！
その結果動いた文字の個数が K 以下にできれば OK

S = “program”、K = 3 で、
T = “aro” と最初の 3 文字だけ決まっているとき
T = “arog” にしても大丈夫か？

S = “program”、K = 3 で、
T = “aro” と最初の 3 文字だけ決まっているとき
T = “arog” にしても大丈夫か？
S

p

r

o

g

r

a

m

T

a

r

o

g

*

*

*

すでに決まっている部分
（不一致 1 文字）

ここを不一致数が
少なくなるように
決めたい

S = “program”、K = 3 で、
T = “aro” と最初の 3 文字だけ決まっているとき
T = “arog” にしても大丈夫か？
S

p

r

o

g

r

a

m

T

a

r

o

g

*

*

*

すでに決まっている部分
（不一致 1 文字）

ここを不一致数が
少なくなるように
決めたい

ここに
使えるのは
m, p, r

S = “program”、K = 3 で、
T = “aro” と最初の 3 文字だけ決まっているとき
T = “arog” にしても大丈夫か？
S
T

p
a

r
r

o
o

g
g

すでに決まっている部分
（不一致 1 文字）

r
*

a
*

m, p, r をうまく
m
*

ここを不一致数が
少なくなるように
決めたい

並び替えて
“ram” との
不一致数を
最小にすればよい！

問題
同じ長さの文字列 s, t が与えられる。
t を並び替えて、s との不一致の数をどれだけ
少なくできるか？
これが解ければいい。
前ページまでの例だと s = “ram”, t = “mpr”

s = “pipeline”, t = “eppstein” の場合を考える
s

p

i

p

e

l

i

n

e

i

n

t’
t’ は並び替え後の t を表すとする
t

e

p

p

s

t

e

同じ文字のところに持ってくれば不一致は減りそう
s

p

t’

p

t

e

i

p

p

e

p

e

p

s

l

t

i

n

e

i

n

e

e

i

n

残りの文字はどう並び替えても不一致になる
s

p

i

p

e

l

i

n

e

t’

p

s

p

e

t

i

n

e

t

e

p

p

s

t

e

i

n

今の直感的な方法が最適になる
・t の文字を順に見ていき、
・s に同じ文字がありそこが空いてれば持っていく
・なければ後回し
・残った t の文字を適当な空いた場所に持っていく
で OK

s に ‘a’ が n 個、t に ‘a’ が m 個あるとする。
このとき、min(n, m) 個の ‘a’ は
並び替えによって一致させられるが、
残りの ‘a’ はどうやっても不一致になる。
さっきの直感的な方法では、
min(n, m) 個ぴったり一致させることができる！

この問題には意外と
簡単に答えられる

同じ長さの文字列 s, t が与えられる。
t を並び替えて、s との不一致の数をどれだけ
少なくできるか？

→ min(s にある a の数, t にある a の数)
+ min(s にある b の数, t にある b の数)
+…
+ min(s にある z の数, t にある z の数)
が答え！

以上で、はじめの擬似コードでごまかした部分を
きちんとプログラムで計算できるようになった。
これで C 問題が解ける。
N の値を小さめにしてあるので、多少の実装方針の差
異で計算量が違っても時間には余裕があると思います。

