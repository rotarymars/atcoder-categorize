改行を無視して 6 文字を読み込み、1 文字目と 6 文字目、2 文字目と 5 文字目、3 文字目と 4
文字目がそれぞれ等しいかどうかを調べればよいです。
以下の実装では、1 文字目から 3 文字目までを配列 a に、4 文字目から 6 文字目までを配列 b
に、それぞれ読み込んでいます。

#i n c l u d e <s t d i o . h>
i n t main ( )
{
char a [ 1 0 ] , b [ 1 0 ] ;
s c a n f (”% s%s ” , a , b ) ;
i f ( a [ 0 ] == b [ 2 ] && a [ 1 ] == b [ 1 ] && a [ 2 ] == b [ 0 ] ) p r i n t f ( ”YES\n ” ) ;
e l s e p r i n t f ( ”NO\n ” ) ;
}

1

なる i の個数と、Bj < Ck なる k の個数の積となります。
よって、全ての j に対し、上述の i, k の個数を数えて掛け合わせ、足し合わせればよいです。
では、i の個数や k の個数はどのように求めればいいでしょうか？

愚直に配列をすべて見る

2

と、O(N ) となり間に合いません。
配列 A, C をあらかじめソートしておきます。すると、i や k の個数は、二分探索を用いて求めるこ
とができます。C++ の場合、標準ライブラリに用意されている lower bound 関数や upper bound
関数を用いるのが良いでしょう。
時間計算量は O(N logN ) となり、間に合います。

#i n c l u d e <s t d i o . h>
i n t main ( )
{
char a [ 1 0 ] , b [ 1 0 ] ;
s c a n f (”% s%s ” , a , b ) ;
i f ( a [ 0 ] == b [ 2 ] && a [ 1 ] == b [ 1 ] && a [ 2 ] == b [ 0 ] ) p r i n t f ( ”YES\n ” ) ;
e l s e p r i n t f ( ”NO\n ” ) ;
}

1

