1. 問題概要
2. 処理（アルゴリズム）

©AtCoder Inc. All rights reserved.

81

•

問題概要

番号がついた箱が無限個並んでおり、左から順番
に、..,-2,-1,0,1,2,..と番号がついている

•

•

いくつかの箱には、マーブルが入っている。
•

番号-100の箱には、赤いマーブルがR個

•

番号0の箱には、緑のマーブルがG個

•

番号100の箱には、青いマーブルがB個

これらのマーブルを、１個隣の箱に移動することが出
来る。

•

全ての箱に、マーブルが２個以上入っていない状態に

する。

©AtCoder Inc. All rights reserved.

82

•

部分点１
•

•

R, G, B ≦ 5

部分点２
•

•

問題概要

R, G, B ≦ 40

満点
•

R, G, B ≦ 300

©AtCoder Inc. All rights reserved.

83

•

処理（アルゴリズム）

例えば、Gが4の時

-3

-2

-1

0

1

2

©AtCoder Inc. All rights reserved.

3

84


処理（アルゴリズム）

•

例えば、Gが4の時

•

マーブルを右に

-3

-2

-1

0

1

2

©AtCoder Inc. All rights reserved.

3

85


処理（アルゴリズム）

•

例えば、Gが4の時

•

マーブルを右に２回移動して

-3

-2

-1

0

1

2

©AtCoder Inc. All rights reserved.

3

86


処理（アルゴリズム）

•

例えば、Gが4の時

•

マーブルを右に２回移動して、さらにもう１個右に

-3

-2

-1

0

1

2

©AtCoder Inc. All rights reserved.

3

87


処理（アルゴリズム）

•

例えば、Gが4の時

•

マーブルを右に２回移動して、さらにもう１個右に

•

最後に左に移動しておしまい

-3

-2

-1

0

1

2

©AtCoder Inc. All rights reserved.

3

88

•

処理（アルゴリズム）

部分点1は、このように、R,G,Bに対して、左右にマーブ
ルを振り分けてあげれば良い。

•
•

深さ優先探索や、幅優先探索を使ってもOK。

部分点2も、右、左、右、左、と振り分けてあげてしま

えば、R,G,Bのマーブルが40個以下、かつ、箱の数が100
個離れているので、重なることもなく、解くことが出
来る。
•

満点解法は、もう少し考察が必要。

©AtCoder Inc. All rights reserved.

89

•

処理（アルゴリズム）

どのマーブルを右に、どのマーブルを左に・・・と考
えるのは非常に面倒！

•

最後の状態だけ考えて、そこから、その状態にするの
に必要な手数を考えたい。

3

2

1 0

1

2

3

3

2

1 0

©AtCoder Inc. All rights reserved.

1

2

3

90

•

処理（アルゴリズム）

どのマーブルを右に、どのマーブルを左に・・・と考
えるのは非常に面倒！

•

最後の状態だけ考えて、そこから、その状態にするの
に必要な手数を考えたい。

•

単純に、移動距離を足し算してあげればＯＫ！
１＋１＋２＝４

3

2

1 0

1

2

3

3

2

１

１ ２

1 0

1

©AtCoder Inc. All rights reserved.

2

3

91

•

処理（アルゴリズム）

R,G,Bが大きくなると・・・

:

:

…

…

©AtCoder Inc. All rights reserved.

92


処理（アルゴリズム）

•

R,G,Bが大きくなると・・・

•

同じ広げ方をすると、被ってしまうことがある！

•

単純に右、左、右、左、と考えるだけではダメ。

…

…

©AtCoder Inc. All rights reserved.

93

処理（アルゴリズム）

•

解法1 広げ方の全探索！
•

図のように、途中で間が空くことはありえない。
3

•

2

1 0

1

2

3

よって、赤・緑・青のマーブルの入っている、一番左
の箱だけ決めれば、最終状態は確定する。
•

これだけだと、それぞれ可能性のある場所が1000近
くあるため、微妙に間に合わない。
•

高速な実装をすればこれでもギリギリ間に合う。
©AtCoder Inc. All rights reserved.

94

•

処理（アルゴリズム）

赤、緑、青に対して、それぞれ全て全探索をすると、
計算量が3乗になってしまい間に合わない。

•
•

何か工夫が必要

緑から先に決めてあげることによって、赤と青を別々

に計算することが出来る！

©AtCoder Inc. All rights reserved.

95

•

処理（アルゴリズム）

例えば図のような場合

©AtCoder Inc. All rights reserved.

96


処理（アルゴリズム）

•

例えば図のような場合

•

まず緑の広げ方を決めてあげる

©AtCoder Inc. All rights reserved.

97


処理（アルゴリズム）

•

例えば図のような場合

•

まず緑の広げ方を決めてあげる

•

すると、赤の広げ方、青の広げ方は、それぞれの広げ
方に干渉しない。

•

よって、2乗の計算量で計算することが可能になる！

©AtCoder Inc. All rights reserved.

98

処理（アルゴリズム）

•

広げる時のコストは、O(1)の計算量で計算することが可
能。

•

それぞれのマーブルの移動距離は、中央で区切ると
等差数列になるため、足し算が可能。

•

3,2,1,0,1,2,3,4,5,6みたいな配列になる。

©AtCoder Inc. All rights reserved.

99

•

処理（アルゴリズム）

そもそも、部分点２と同じ並べ方をまず試してみて、
それが収まるなら、探索する必要はない。

©AtCoder Inc. All rights reserved.

100

•

処理（アルゴリズム）

そもそも、部分点２と同じ並べ方をまず試してみて、
それが収まるなら、その解を採用すれば良いので、探

索する必要はない。
•

収まらないなら、限界まで中央に寄せてあげれば良い

ので、こちらも探索する必要はない。

©AtCoder Inc. All rights reserved.

101


処理（アルゴリズム）

•

緑が中心だとダメな例！

•

緑・赤が多くて、青が少ない場合。

©AtCoder Inc. All rights reserved.

102


処理（アルゴリズム）

•

緑が中心だとダメな例！

•

緑・赤が多くて、青が少ない場合。

•

赤を跳ね飛ばすと、赤を大量に移動させないといけな
くなってしまう。

©AtCoder Inc. All rights reserved.

103


処理（アルゴリズム）

•

緑が中心だとダメな例！

•

緑・赤が多くて、青が少ない場合。

•

赤を跳ね飛ばすと、赤を大量に移動させないといけな
くなってしまう。→緑を右に移動してあげないといけ

ない！

©AtCoder Inc. All rights reserved.

104


処理（アルゴリズム）

•

解法２

•

左の箱から順番に、「赤を置く」「緑を置く」「青を

動的計画法を使おう！

置く」「置かない」の4通りの全探索が考えられる。
•

範囲は適当に-1000から+1000の箱までやるとして、2000

回程度の分岐
•

このまま全探索すると、4^2000程度の計算量
•

これを、動的計画法orメモ化再帰をしてあげること
により、解いてあげる。

©AtCoder Inc. All rights reserved.

105

•

処理（アルゴリズム）

まず、一番左に対して４つの分岐

©AtCoder Inc. All rights reserved.

106

•

処理（アルゴリズム）

まず、一番左に対して４つの分岐

©AtCoder Inc. All rights reserved.

107


処理（アルゴリズム）

•

動的計画法・メモ化再帰とは？

•

一度計算したものを、二度計算しなかったり、同じも

のを纏めて計算してあげることにより、計算量を大幅
に削減してあげるテクニック

©AtCoder Inc. All rights reserved.

108

•

•

処理（アルゴリズム）

今回の場合は、左から順番に探索してあげるとして、
•

どの箱を見ているか

•

赤いマーブルがいくつ残っているか

•

緑のマーブルがいくつ残っているか

•

青のマーブルがいくつ残っているか

しか状態が存在しない。

©AtCoder Inc. All rights reserved.

109


処理（アルゴリズム）

•

動的計画法の場合

•

適当な４次元配列dpを用意する

•

dp[今見ている場所][赤の残り数][緑の残り数][青の残り
数]

•

これに対して、「この状況になるための最小の移動
数」を格納してあげるような、計算の省略を行う。

©AtCoder Inc. All rights reserved.

110


処理（アルゴリズム）

•

深さ優先探索を利用したメモ化再帰の場合

•

int dfs(今見ている場所,赤の残り数,緑の残り数,青の残り

数)のような再帰関数を作る。
•

返り値は、その先で全てのマーブルを配置するため

に必要な移動数

©AtCoder Inc. All rights reserved.

111

•

処理（アルゴリズム）

このように動的計画法・メモ化再帰を行うと、それぞ
れの状態数は、2000 * 300 * 300 * 300程度存在し、それ

ぞれに対して分岐の数が4つ。
•

これでは計算量が大きすぎる！

•

もう少し工夫をしてあげる必要がある。

©AtCoder Inc. All rights reserved.

112

•

処理（アルゴリズム）

考察をすることで、計算量を削減しよう！
•

先ほどは、「赤を置く」「緑を置く」「青を置く」

の3通りの置き方を考慮していた。
•

しかし、左から順番に、赤・緑・青と並ぶのが自然

であり、赤が置けるなら緑・青を置く必要はないし、
緑が置けるなら青を置く必要はない。（今回の問題
設定では出来ない！）
•

つまり、分岐の数を4つから2つ（置く、置かない）
に減らせる！
©AtCoder Inc. All rights reserved.

113

•

処理（アルゴリズム）

さらに、置くマーブルの順番を決めてしまえば、それ
ぞれのマーブルの個数でなく、全てのマーブルの残り

個数の和だけ覚えておけば、次に置くのはどのマーブ
ルかを求めることが出来る！

•

残りマーブルの状態数が、300 ^ 3から、300 * 3に削
減できる！

•

これなら制限時間内に解くことが可能となる

©AtCoder Inc. All rights reserved.

114


処理（アルゴリズム）

•

動的計画法の場合

•

適当な2次元配列dpを用意する

•

dp[今見ている場所][マーブルの残り数]
•

これに対して、「この状況になるための最小の移動

数」を格納してあげるような、計算の省略を行う。
•

マーブルの残り数に対して、移動量の計算が変わる
ので注意！

©AtCoder Inc. All rights reserved.

115


処理（アルゴリズム）

•

深さ優先探索を利用したメモ化再帰の場合

•

int dfs(今見ている場所,マーブルの残り数)のような再帰

関数を作る。
•

返り値は、その先で全てのマーブルを配置するため

に必要な移動数
•

こちらもマーブルの残り数から、R,G,Bどのマーブル
を使うか求める必要があるので注意。

©AtCoder Inc. All rights reserved.

116

•

処理（アルゴリズム）

解法３

最小費用流を使おう！（想定外でした。）

•

Komakiさんの解法からのアイデアです。

•

http://abc004.contest.atcoder.jp/submissions/132198

©AtCoder Inc. All rights reserved.

117

•

処理（アルゴリズム）

こんな感じでグラフを作る
•

辺には容量と重みを持たせる

(1, -100から箱の距離)
(R,0)
Ｓ

(1,0)
(1,0)

(G,0)

Ｔ

(1,0)
(B,0)

(1,0)
©AtCoder Inc. All rights reserved.

118

•

こんな感じでグラフを作る
•

•

処理（アルゴリズム）

辺には容量と重みを持たせる

このグラフの最小費用流を求める！
(1, -100から箱の距離)
(R,0)

(1,0)
(1,0)

(G,0)
(1,0)
(B,0)

(1,0)
©AtCoder Inc. All rights reserved.

119

処理（アルゴリズム）

•

最小費用流って？
•

グラフ（丸と矢印で構成されたさっきの図みたいな

もの）に関する有名なアルゴリズム
•

辺に、「容量」「重み」を持つグラフに対して、始

点から終点までフローを流す。
•

各辺には、辺の容量の分だけフローを流すこと
が可能であり、流すごとに重み分のコストがか
かる。

•

必要なフローを流すために必要なコストの最小値を

求めるアルゴリズム。
©AtCoder Inc. All rights reserved.

120

•

処理（アルゴリズム）

最小費用流の解き方
•

グラフを作ったら、ダイクストラで頑張る！

•

ダイクストラで1つのフローを流し終えたら、逆の
辺を作る。

•

フローが流せなくなるまでダイクストラを繰り返
す！

•

詳しくはググってね！

©AtCoder Inc. All rights reserved.

121


