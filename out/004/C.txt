1. 問題概要
2. 処理（アルゴリズム）

©AtCoder Inc. All rights reserved.

64


問題概要

1. 1から6までの数字が割り振られた、6枚のカー
ドが左から順に整列している。
2. 整数N(1≦N≦10^9)が与えられる。
3. i=0からi=N-1までのN回、カードを入れ替える。
➢ 左から{(i%5)+1}番目のカードと、
左から{(i%5)+2}番目のカードを入れ替える。

©AtCoder Inc. All rights reserved.

65

•

補足（剰余について）

剰余演算子 % について
➢ 要は「余り」のこと
➢ 7%3 は「7を3で割った余り」を意味する
◆ つまり1
➢ ほとんどのプログラミング言語では%が剰余
演算子として実装されている

©AtCoder Inc. All rights reserved.

66


処理（アルゴリズム）

1. この問題のポイントは、Nの値に大きな値が含
まれること(最大でN=10^9まで)
2. つまり、普通に交換していくだけでは時間的な
制約上、満点を得るのは厳しい(2s以内)
3. ここに気づくことができるかが、満点を得るた
めのポイント
➢ できるだけ交換回数を減らしたい！
©AtCoder Inc. All rights reserved.

67


•

処理（アルゴリズム）

とはいえ、まずは実験してみる

1

2

3

4

5

6

i=0

2

1

3

4

5

6

i=1

2

1

4

5

6

初期状態

3

©AtCoder Inc. All rights reserved.

68


•

処理（アルゴリズム）

まずは実験してみる

i=2

2

3

4

1

i=3

2

3

4

5

i=4

2

3

4

5

©AtCoder Inc. All rights reserved.

6

5

6

1

6
1
69

•

処理（アルゴリズム）

あれ？1が右端に移動して2~6までは整列している・・・?

i=4

2

3

•

さらに実験してみる

i=5

3

2

4

5

6

1

4

5

6

1

©AtCoder Inc. All rights reserved.

70


•

処理（アルゴリズム）

さらに実験してみる

i=6

3

4

i=7

3

4

5

i=8

3

4

5

2

6

©AtCoder Inc. All rights reserved.

5

6

1

2

6

1

2

1
71


処理（アルゴリズム）

3

i=9

4

5

6

1

2

•

先頭から3~6が整列している。で、後ろに1と2が並んでいる。

•

ということは、もっと進めてみると以下のようになるのでは？

i=?

4

5

6

1

©AtCoder Inc. All rights reserved.

2

3
72

•

処理（アルゴリズム）

さらにさらに進めると、きっとこういった遷移が行われるはず

i = ??

5

6

1

2

3

4

i = ???

6

1

2

3

4

5

i = ????

1

2

3

4

5

6

©AtCoder Inc. All rights reserved.

73

処理（アルゴリズム）

•

iがいくつのときかはわからないけれど、初期状態に帰ってくる？
➢

あくまでも現段階では予想である

i=0

1

2

3

4

5

6

i = ????

1

2

3

4

5

6

©AtCoder Inc. All rights reserved.

74

•

処理（アルゴリズム）

確かめてみる！
➢

方法は、カードの遷移を出力する

i = 0 213456
i = 1 231456
i = 2 234156
：
i = 29 123456
i = 30 213456

©AtCoder Inc. All rights reserved.

発見！

75

•

処理（アルゴリズム）

確かめてみる！
➢

方法は、カードの遷移を出力する

交換回数はiが
0から29までの30回

i = 0 213456
i = 1 231456
i = 2 234156
：
i = 29 123456
i = 30 213456

カードが6枚あって、入れ替え可能な場所が5通りあるから
6 x 5 = 30回交換すると初期状態に戻る
©AtCoder Inc. All rights reserved.

76

•

処理（アルゴリズム）

実験の結果、30回交換すると初期状態に戻ることがわ
かった。

➢ 31回の交換は、1回の交換と同じ。
➢ 32回の交換は、2回の交換と同じ。

➢ 100回の交換は？
◆ 100 mod 30 => 10 より、10回の交換と同じ
◆ 30で割ったときの余り（剰余）がポイント
• Nを30で割ったときの余りで交換すればよい

©AtCoder Inc. All rights reserved.

77

•

処理（アルゴリズム）

これでNの値が大きくなっても対応できる！
➢ たとえば、N = 1000 のとき、実際に1000回交換する

のではなく、1000 mod 30 => 10回交換すればよい
➢ 30で割ったときの余りは、0~29の30通りあるが、

最大でも29回ですむ。

N = N % 30;
としておけばよい
©AtCoder Inc. All rights reserved.

78


処理（アルゴリズム）

•

数値の入れ替えの仕方

•

A, Bを入れ替えたい時の処理

•

•

C = A;

•

A = B;

•

B = C;

のように、Cを中継してあげれば入れ替えることが出来
る。

•

C++などは、標準でswap関数が用意されている

©AtCoder Inc. All rights reserved.

79

AtCoder Beginner Contest #004
解説資料

続き

2014年 2月 16日
AtCoder株式会社 高橋直大
©AtCoder Inc. All rights reserved.
80

