
盤面が大きいので、実際に 2 次元配列で塗ることをシミュレーションすることはできま
せん。また、 N が 105 と大きいので、座標圧縮したとしても、メモリ使用量が O(N 2 )
となり厳しいです。
ここで気づくべきポイントは、「一つの黒く塗られたマスが影響を与える範囲は、その
周辺にあるいくつかの 3 × 3 領域しかない」ことです。すなわち、それぞれの塗られたマ
スに対し、これらの周辺の少しのマスにのみ何かの処理をするだけで計算できれば、高速
に答えが求められることになります。
(i, j) を、上から i 行目で左から j 行目のマスを左上とする 3 × 3 の正方形を表すこと
にします。例えば、上から p 行目で左から q 行目のマスを黒く塗ると、 (p − k, q − l)(k =
0, 1, 2)(l = 0, 1, 2) に含まれる黒いマスが 1 つ増えます。(ただし、これらの正方形が盤面
からはみ出すことがあるので、そういうケースは除外します)
ということで、入力で与えられる点に対してこれらの正方形の左上のマスを全部列挙し
ておき (最大で 9N 個列挙される)、その列挙されたものの中で、それぞれの正方形が何回
出現するかがカウントできればよいです。
これは、pair 型などで (i, j) をソートして前から順に同じ値が何回出てくるかを数えて
も良いですし、map 等のデータ構造を使ってもよいです。
最後に、黒いマス 0 個の個数は、全体 ((H − 2)(W − 2) 個) から 1 回以上黒いマスが
出現した 3 × 3 領域の個数を引けば求められます。
計算量は、O(N logN ) となります。

5

