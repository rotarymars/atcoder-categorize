表面的なことですが、文字列 S の ABC 数を「S の文字のうち 3 文字に丸をつけ、丸をつけた文字を左か
ら読むと ABC となるようにする方法」と捉えると考えやすいかもしれません。求めたいのは、
「S に含まれる

? をそれぞれ A, B, C のいずれかに書き換えつつ、S の文字のうち 3 文字に丸をつけて、丸付きの文字が左か
ら ABC となるようにする方法」です。
こ の よ う に 考 え る と 、動的計画法（リンク先は Wikipedia の同名の記事）の 適 用 が 見 え て き ま す 。値

dpi,j (0 ≤ i ≤ |S|, 0 ≤ j ≤ 3) を「S の先頭から i − 1 文字目までに対する処理（? の置換と丸つけ）をすでに
行っていて、これまでに丸を j 個つけている場合の、S の残りの部分に対する処理を行う方法の個数」とする
と、以下が成り立ちます（文字列の先頭の文字を 0 文字目とします）。

• dp|S|,3 = 1
（処理が正常に終了。これから行うべきことは「何もしない」の 1 通り）

• j < 3 のとき、dp|S|,j = 0
（丸を 3 個つける前に最後の文字まで見終わってしまい、手遅れ。これからできることは 0 通り）

• i < |S| のとき、dpi,3 = m × dpi+1,3 , ここで Si = ? なら m = 3, そうでなければ m = 1
（丸は 3 個つけ終わったので、あとは ? を置換するのみ）

• i < |S|, j < 3 のとき、dpi,j = m1 × dpi+1,j + m2 × dpi+1,j+1 ,
ここで Si = ? なら m1 = 3, そうでなければ m1 = 1 であり、

Si = ? または Si が ABC のうち j 番目（0 から数えて）の文字なら m2 = 1, そうでなければ m2 = 0
（式の前半部分は i 文字目に丸をつけない場合、後半部分は丸をつける場合に対応）
これを元に dpi,j (0 ≤ i ≤ |S|, 0 ≤ j ≤ 3) の値を i, j の降順にすべて求めることができ、O(N ) 時間の解法
が得られます。
参考実装 (提出 #2955456, C++)

4


