実行時間制限が許すならば、100 点の問題を何問解き、200 点の問題を何問解き、…という配点ごとの解く
問題の数の組み合わせをすべて試して最良のものを採用すればよいです。しかし、最大で 10 種類の配点それ
ぞれに対して問題が最大で 100 問存在するため、このような組み合わせは最大で 10110 通り存在します。こ
れらをすべて試すには 1 万年以上の時間が必要となるでしょう。
しかし、最適解を求める上で 10110 通りすべての組み合わせを試す必要はありません。例えば、100 点の問
題と 200 点の問題が 10 問ずつあったとして、最終的にこれらを 3 問ずつ解く、という選択を考慮する必要
はありません。なぜなら、その代わりに 200 点問題を 6 問解くことで、解く問題数を増やさずに総合スコア
を高くすることができるからです。
以下、「100i 点の問題を pi 問解く」ことを「100i 点を完全に解く」、
「100i 点の問題を 1 問以上 pi − 1 問
以下解く」ことを「100i 点を中途半端に解く」
、
「100i 点の問題を 0 問解く」ことを「100i 点をまったく解か
ない」と表現します。上の議論を一般化すると、以下のような選択のみを考慮しても最適解はそれらの選択に
含まれます。

• 中途半端に解く配点は 1 種類以下であり、それ以外の配点は完全に解くかまったく解かない。
• 中途半端に解く配点があるなら、それは完全に解く配点以外の配点の中で最も高い配点である。
このような選択をすべて列挙するには、D 種類の配点それぞれに対してその配点を完全に解くか否かを決
定し、必要であれば残りの配点のうち最も高いものを中途半端に解く配点とすればよいです（中途半端に解く
配点の問題を 1 問除きすべて解いても目標点に達しない場合は、完全に解く配点の選択が不適切であったと
して無視します）
。
この方針を実装するには、再帰関数を定義するか、0 以上 2D − 1 以下の整数それぞれの 2 進数表記を D
回の選択を表すリストのようなものとして用いる（下から i 桁目 (0 ≤ i < D) が 1 なら 100(i + 1) 点を完全
に解き、0 なら完全には解かない）のが素直でしょう。素直な実装で O(2D D) 時間の解法が得られます。
参考実装 (提出 #2954675, C++)

3

