
		公式
		
			
				F - Substring 2 解説
			
			by  tatyam
			
		
		
		
		
			この問題は、\(S\) から長さ \(|T|\) の部分文字列を取り出したときの \(T\) とのハミング距離を最小化する問題と見ることができます。
すなわち、\(s_i\) を \(S\) の \(i\) 文字目、\(t_i\) を \(T\) の \(i\) 文字目、\(\oplus\) を XOR の演算子として、  \(\displaystyle \min_{0 ≤ i ≤ |S| - |T|} \sum_{j=1}^{|T|}(s_{i + j} \oplus t_j)\) が答えになります。

\(\displaystyle \sum_{j=1}^{|T|}(s_{i + j} \oplus t_j)\) を全ての \(i\) について求めることを考えてみましょう。
愚直に求めると計算量が \(\Theta(|S||T|)\) になり TLE してしまいますが、式が畳み込みのような形になっていることに注目し、\(T\) を左右反転して \(\displaystyle \sum_{j=1}^{|T|}(s_{i + j} \oplus t_{|T|-1-j})\) とします。

以下 \(T\) は左右反転しておくものとします。
\(S\) と \(T\) の以下の式により畳み込んだものを \(C = (c_2, c_3, \dots, c_{|S|+|T|})\) とすると、
\[
c_i = \sum_{i=j+k}s_j \oplus t_k
\]です。ここで、\(c_{i+|T|-1} = \displaystyle \sum_{j=1}^{|T|}(s_{i + j} \oplus t_{|T|-1-j})\) であるので、この畳み込みを高速に求めればこの問題を解くことができます。
畳み込みの XOR の部分が掛け算であれば高速フーリエ変換による畳み込みが使えるので、XOR を掛け算に分解します。
\[
c_i = \sum_{i=j+k}s_j(1 - t_k) + \sum_{i=j+k}(1 - s_j)t_k
\]これで、高速フーリエ変換を利用して \(C\) を \(O((|S| + |T|) \log(|S| + |T|))\) で求められるので、この問題を解くことができました。

実装には AC-Library の convolution を利用できます。

回答例 (C++)



回答例 (Python)



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
