1. 問題概要
2. 解法

2015/10/24

©AtCoder Inc. All rights reserved.

13


• 1からNの整数 i に対し、i→bi という移動が決まって
いる
• 初め a にいるものとする。k 回移動したとき、どこに
いるだろうか？
• 制約
– 2<=N<=100000
– 20点: k<=100000
– 80点: k<=10100000

2015/10/24

14


• 20点解法は、ミカミくんの移動をシミュレーションす
ればOK ( O(k) )
• グラフにして考えてみよう！
– N個の頂点のある有向グラフで、それぞれの頂点からは1
つのみ辺が出ている(入ってくる辺は複数あるかも)
1
4
6

2
5

3

←サンプル1


• どの頂点も、辺を辿って行くといくつか進んだ後は閉
路に到達しその閉路の中をずっと辿り続ける
– 頂点はN個しかないので、ずっと辺を進んでいくといつか
は今まで辿ったことのある頂点に戻ってくる。どの頂点も
出て行く辺はちょうど1本なので、戻ってきた後は全く同じ
移動を繰り返すから
こんなイメージ→
a

• (蛇足)全体のグラフは、連結成分(辺でつながっている頂点たち)
ごとに分けると、連結成分のどの頂点も最後にぐるぐる回ること
になる閉路と、その閉路に向けてつながる木の部分からなる


• 閉路の長さをC、 閉路に到達するまでの長さをT とおき
ます。
• k が十分大きく、k 回移動したときに閉路に到達している
ものとします。
• このとき、k mod C (k を C で割った余り) さえ求まればOK
– 閉路に到達しているぐらい十分大きいなら、C 回違ってもちょう
ど閉路1周分違うので、到達する頂点は変わらない
– 始点aから k mod C 回動けばいい(厳密にはちょっと違いますが
後述)

• ひとまず k mod C を求めてみる
– 多倍長を使ってもOKですが、多倍長無しで簡単に求める方法
があります(桁DPなどでよく使うので、多倍長の付いた言語を
使っている人にも有用なテクです)


• k の長さを L とおきます。
• k = (k の L-1 文字目までを整数として捉えたも
の)*10+(kの最後の数字の数) となる
– Ex. 334=33*10+4
– Ex. 123456=12345*10+6

• このことに注目すると、(kのL-1 文字目まで) mod C
が求まっていればよさそう。
• この1桁減らした数に帰結することを繰り返すと、
大きい数の桁から見ていき、今までの数に10を掛
け、今見ている桁の数を足す 操作を繰り返せば、
k mod C が求まる。

– kを文字列として
保存するとこんな感じ→

• 始点 a からk mod C 回動けばいい
– ただし、k回移動したときに閉路に入っていることを仮定
していたので、 k mod C が T より小さいとき、T以上にな
る(移動後の場所が閉路に入る)まで移動回数に C を足
す必要がある
• つまり、k を移動後の場所が変わらない範囲で小さくしたかった。
k を k mod C にする操作は、kからCを引けるだけ引く操作なの
で、減らしすぎた分を戻す感覚

– k mod C < C <= N なので、シミュレーションは高々O(N)


• k 回動いた後に閉路に到達していないとき
– 閉路に到達していないということは、同じ頂点を2回通っ
ていない
– 頂点はN個しかないので、高々N回しか移動していな
い！つまりk<=N
– これならそのままシミュレーションすればOK
– 逆に、k<=Nでも閉路に到達している場合もあるが、その
ような場合もシミュレーションで答えは正しく求まる
– なので、kがN以下のときはシミュレーション、それより大
きければ閉路に入っていると仮定して解いてOK


