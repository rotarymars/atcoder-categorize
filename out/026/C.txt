1. 問題概要
2. アルゴリズム

2015/7/11

©AtCoder Inc. All rights reserved.

21


• 社員がN人いる
• 社長以外の社員は、上司を一人だけ持っている
• 社員の給料は、直属の部下の給料の最大値・最小
値から算出できる
• 社長の給料を求めよ
• 制約
• 1 ≦ N ≦ 20

2015/7/11

22


• やるべきことは、問題文に書かれている処理を忠実
に書くだけ
– その書き方が難しい！

• どうして難しいか？
– 自分の給料を決めるのは、「部下の給料」を知る必要が
あるのに、「部下の一覧」は入力で与えられない
• 「部下の一覧」ではなく「上司」が与えられる

– 高橋君の給料を求めようと思っても、まず部下の給料を
求めないといけない！
• 計算順序とかをちゃんと考えないといけない

• 部下がいない時だけ計算式が違う
2015/7/11

23


• 気付くべきこと
– 上司の番号は、必ず自分の番号より小さい
• つまり、部下の番号は、必ず自分の番号より大きい
• 自分より大きい社員番号の社員を、全部調べることにより、自分
の給料を算出できる
• つまり、社員番号の大きい社員から順番に、給料を求めれば良
い

– 上司の番号が与えられているなら、それを適当に処理す
れば、部下の一覧も作れる
• ListやVectorなどの配列を使うことで、適当に対応できる！

2015/7/11

24


• 実装方法
– 実装１：ループによる実装（もらう型）
– 実装２：ループによる実装（配る側）
– 実装３：再帰による実装

2015/7/11

25


• 実装１：ループによる実装（もらう型）
– 予め部下リストを作る
– 逆順に、部下リストから最大値と最小値を求め、給料を求めて
いく
for(int i = N - 1; i >= 0; i--){
if(sub[i].size()==0){P[i] = 1; continue;}
maxP[i] = 0; minP[i] = (int)1e9;
for(int j: sub[i]){
maxP[i] = max(maxP[i], P[j]);
minP[i] = min(minP[i], P[j]);
}
P[i] = maxP[i] + minP[i] + 1;
}
2015/7/11

26


• 実装２：ループによる実装（配る型）
– 逆順に処理していく
– 上司の最大値と最小値を更新し、、給料を求めていく

for(int i = 0; i < N; i++){maxP[i] = 0; minP[i] = (int)1e9;}
for(int i = N - 1; i >= 0; i--){
if(maxP[i]==0) P[i] = 1;
else P[i] = maxP[i] + minP[i] + 1;
maxP[boss[i]] = max(maxP[boss[i]], P[j]);
minP[boss[i]] = min(minP[boss[i]], P[j]);
}
2015/7/11

27


• 再帰による実装
– 部下リストを予め作る
– 再帰で更新する
int dfs(int id){
if(sub[id].size() == 0) return 1;
int minP = (int)1e9; int maxP = 0;
for(int i: sub[id]){
int P = dfs(i);
minP = min(minP, P);
maxP = max(maxP, P);
}
}
2015/7/11

28


• おまけ 部下リストの作り方
– boss[i]が、iの上司がboss[i]であることを示す
– 上司の部下リストに自分を追加する、ということを繰り返
すことで作れる
– 擬似コードは↓のような感じ

List<int> sub[N];
for(int i=0;i<N;i++){
sub[boss[i]].add(i);
}
2015/7/11

29


• 考察
– 「答えが非常に大きくなる」というが、どれくらいか？
• 1の部下が2, 2の部下が3…というような構造になってる時が、最も
大きくなる
• この時、2^n – 1が高橋君の給料になる。
– 今回の問題だと、1048575とかなので、int型で十分

– 計算量も気にしないで良い
• 紹介したどの実装でもO(N)、かつNが20以下なので余裕
• 1億を超えるようなときだけ気を付けよう！

2015/7/11

30

