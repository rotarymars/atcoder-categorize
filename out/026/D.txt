1. 問題概要
2. アルゴリズム

2015/7/11

©AtCoder Inc. All rights reserved.

31


• 高橋君が、高橋君ボールを投げる
• 投げた時間に対する距離f(t)は、以下の数式で表せ
る
– f(t) = At + Bsin(Ctπ)

• f(t) = 100となるtを1つ求めよ
• 制約
– 1 ≦ A,B,C ≦100

2015/7/11

32


• そもそもどんな関数なのかな？
– 二つに分けて考えよう！
• At
– tに対してAだけ増加する直線

• Bsin(Ctπ)
– 周期2/CのsinカーブをB倍したもの

– つまり、「直線」と「sinカーブ」を足し合わせた関数
– f(t)=100を、数学的に直接求めようとするのは難しそう！
• であれば、何か工夫して求めてみよう！

2015/7/11

33


• 関数のイメージ
– 大体こんな感じ！
• うねうねしながら増えてく

2015/7/11

34


• 直接答えを求められないときはどうすれば良いか？
– 二分探索を使えば良い！
• f(t)のtに、適当な値を入れる
– f(t)が100より大きければtはそれより小さく、100より小さければ、tは
それより大きいことを利用する

• 具体的なアルゴリズム
– 答えがt=0からt=10000の間にあるとする
– ちょうど真ん中のt=5000を試す
– f(t)<100なら、答えは5000から10000の間にあり、そうでないなら、0
から5000の間を調べれば良い
– これを繰り返し、十分な精度になるまで答えを半分にしていく

• これで本当に良い？
– 関数が単調増加な関数でないので、これでは、f(t)=100のtの最小値
などは求められない
– しかし、f(t)=100となる、tの1つを求めるだけなら、これで十分！

2015/7/11

35


• なぜ二分探索で答えが求められるのか？
– 例えば、f(t)=100がこの黒い線だったとする
• 解となるtは、最低1つはあり、図のようにたくさんある場合もある

2015/7/11

36


• なぜ二分探索で答えが求められるのか？
– 例えば、f(t)=100がこの黒い線だったとする
• 解となるtは、最低1つはあり、図のようにたくさんある場合もある

– 今、青い線の間に答えがある、というところまで絞れてお
り、緑の線の間に答えがあることが解っているとする
• どちらを取っても解の取りこぼしが起こる？

– 取りこぼしは発生するが、
左の範囲を選択した時に、
絶対に解の1つが間にある事が
保証される！

2015/7/11

37


• なぜ解が必ずあるか？
– この関数f(t)は、tに対して連続である
– f(左青)≦100≦f(緑)の時、f(t)は連続であるので、左青と
緑の間に、必ずf(t)=100となるtが存在する！
• 平均値の定理

2015/7/11

38


• 擬似コードはおおよそこんな感じ
– t≧200であれば、f(t)≧100は簡単に示せる

double low = 0; high = 200;
for(int i=0;i<100;i++){
double mid = (low+high)/2;
if(f(t)<100) low = mid;
else high = mid;
}
print(low);
2015/7/11

39


• 注意点
– 誤差が非常に厳しいので気を付けましょう！
• f(t)の誤差が10^-6まで許される
– tが10^-9程度変わると、f(t)は10^5くらい変わったりする
– よって、10^-11程度の精度はあった方が安心
– 二分探索の打ち切り条件に気を付けよう！
– 出力桁数にも注意しよう！

2015/7/11

40


