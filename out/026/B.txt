1. 問題概要
2. アルゴリズム

2015/7/11

©AtCoder Inc. All rights reserved.

10


• N個の円が与えられる。これらの円はすべて中心が
原点であり、半径が違う
• 外側から赤白交互に色を塗っていく
• 赤く塗られた部分の面積を求めなさい
• 制約
• 1 ≦ N ≦ 1,000
• 1 ≦ Ri ≦ 1,000

2015/7/11

11


• 入力
– 整数Nを受け取る
– 各円の半径Riをn個受け取る
• 今回はスペース区切りではなく、改行区切りなので、何度も受け
取るだけ
• 詳しくはpracticeで確認しよう！
– http://practice.contest.atcoder.jp/tasks/practice_1

2015/7/11

12


• 処理
– 色を塗られた部分の面積を求めなければならない

2015/7/11

13


• 処理
– 色を塗られた部分の面積を求めなければならない
– まず、最初は何も塗られていない状態

2015/7/11

14


• 処理
– 色を塗られた部分の面積を求めなければならない
– まず、最初は何も塗られていない状態
– そこから、まず一番外側の円を赤く塗る

2015/7/11

15


• 処理
– 色を塗られた部分の面積を求めなければならない
– そこから、まず一番外側の円を赤く塗る
– 次に、２番目の円を白く塗る

2015/7/11

16


• 処理
– 色を塗られた部分の面積を求めなければならない
– そこから、まず一番外側の円を赤く塗る
– 次に、２番目の円を白く塗る
– これを繰り返すことで、全ての色を塗ることが出来る

2015/7/11

17


• 処理
– 色を塗られた部分の面積を求めなければならない
– そこから、まず一番外側の円を赤く塗る
– 次に、２番目の円を白く塗る
– これを繰り返すことで、全ての色を塗ることが出来る
– では、どう計算すればいいか？
• 赤く塗る、の部分で、塗った面積を足す
• 白く塗る、の部分で、塗った面積を引く

– 上記を繰り返すことにより、赤い部分の面積を求めること
が出来る
2015/7/11

18


• 解法まとめ
– まずはRiの値を大きい順にソートする
• ソートアルゴリズムは、大体の言語で標準で実装されている
• 普通は昇順（小さい順）にソートされるので注意
– 小さい順に処理をすると混乱しやすいが、別にできなくはない

– 次に、外側の円から順番に、面積を計算していく
• 赤・白が交互に出てくることに注意
• 円の面積は、(半径)×(半径)×(円周率)
• 円周率は、3.14じゃダメ！標準で入っている言語が多いです。
– 入っていない場合は、調べて十分な精度までコードに埋め込みま
しょう。

– 最後に回答を出力
2015/7/11

19


• 出力
– 今回は、小数を出力する必要がある
– 小数の出力方法も、言語によって違う
• 練習ページには書いていないので、ほかの人の提出を見よう！

– 普通に出力すると、様々な問題があります。
• 桁数が大きいときに、指数表示で出力されてしまう
• 値が小さい時に、十分な精度の出力が行われない

– 以上のようなことを避けるため、出力フォーマットを明記し
ましょう。
• C/C++なら、printf(“%.14f¥n”, ans);など

2015/7/11

20

