
		公式
		
			
				G - Range Sort Query 解説
			
			by mechanicalpenciI
			
		
		
		
		
			順列 \(P_i\) について \(P_i\leq x\) ならば \(A_i=0\) 、\(P_i\geq x+1\) ならば \(A_i=1\) とした \(01\) 列 \(A\) を用意し、これがクエリによってどう変更されるか考えます。 もし、 \(x=K-1\) としたときと \(x=K\) としたときについて、すべてのクエリを処理した後の \(01\) 列が分かれば、その差分から \(P_i=k\) である \(i\) を求めることができます。具体的には前者では \(0\) , 後者では \(1\) であるような場所が \(1\) つだけ存在し、その場所が \(P_i=k\) であるようindex \(i\) の場所です。

クエリについて、まず \(C_i=1\), すなわち昇順にソートするものを考えます。\(A_{L_i}, A_{L_i+1}, \ldots ,A_{R_i}\) に \(0\) が \(a\) 個、 \(1\) が \(b\) 個 \((a+b=R_i-L_i+1)\) 含まれていたとします。このとき \(P_j\)  \((L_i\leq j\leq R_i)\) の具体的な値が何であったかに関わらず、ソート後の順列に対応する \(01\) 列のこの範囲には \(a\) 個の \(0\) と \(b\) 個の \(1\) が、この順で並びます。すなわち、 \(0,0,\ldots, (a個),\ldots,0,1,1,,\ldots, (b個),\ldots,1\) となります。これは次の操作と同値です。


\(S=A_{L_i}+A_{L_i+1}+\cdots +A_{R_i}\)  を求める。
\(A_{L_i}, A_{L_i+1}, \ldots ,A_{R_i-S}\) の値を一括して \(0\) に変更する。
\(A_{R_i-S+1}, A_{R_i-S+2}, \ldots ,A_{R_i}\) の値を一括して \(1\) に変更する。


同様にして、\(C_i=2\), すなわち降順にソートする操作も \(01\) 列に対しては、


\(S=A_{L_i}+A_{L_i+1}+\cdots +A_{R_i}\)  を求める。
\(A_{L_i}, A_{L_i+1}, \ldots ,A_{L_i+S-1}\) の値を一括して \(1\) に変更する。
\(A_{L_i+S}, A_{L_i+S+1}, \ldots ,A_{R_i}\) の値を一括して \(0\) に変更する。


という操作と同値である事が分かります。

これらの操作は遅延セグメント木によって行うことができます。
よって、初期状態の順列から \(01\) 列を構成し、遅延セグメント木の上でクエリによる更新操作を行い、最終的な \(01\) 列についてその差分を調べれば良いです。計算量は最初の構築および最後の差分検索に\(O(N)\), 更新はクエリごとに \(O(\log N)\) であるため全体で \(O(N+Q\log N)\) であり、十分高速です。よって、この問題を解く事が出来ました。

c++による実装例 :



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
