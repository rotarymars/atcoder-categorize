
		公式
		
			
				E - Count Simple Paths 解説
			
			by  Nyaan
			
		
		
		
		
			この問題は「パスの本数」という慣れない数え上げを要求する問題で、上手く解けずに困ってしまった方が多いかもしれません。ところが実は、C 問題でも出てきた深さ優先探索 (DFS) を応用すれば、素朴なアルゴリズムでこの問題を実装することができます。
具体的には、以下の Python 風の疑似コードで表せる DFS を実装します。(訪問したかどうかを管理する変数 vis のフラグの立て方が通常の dfs と少し異なるのがポイントです。)



このDFS は、 1 つの状態に 1 つのパスが対応しています。具体的には DFS 内部の path に格納されている頂点の列として表せるパスが DFS の状態と対応しています。


ここでの「状態」というのは、DFS の遷移の過程を根付き木として表したときの各頂点のことを指します。また、状態とパスが 1 対 1 で対応しているのは帰納法により証明できます。


よって DFS で訪問する状態の個数が答えとなり、これは実際に DFS を動作させれば調べられます。ただし、パスの本数が \(10^6\) 以上になった場合はその時点で DFS を打ち切り、答えは \(10^6\) となります。

計算量を考えます。疑似コードの関数 dfs は高々 \(10^6\) 回しか呼び出されず、dfs 内部での計算量は頂点 \(c\) の次数 \(\mathrm{deg}(c)\) で抑えられます。各頂点の次数は高々 \(10\) なので、ステップ数は \(10^6 \times 10 = 10^7\) オーダーで抑えられるため、このアルゴリズムは ACするのに十分高速に動作します。


実装例 (C++)




		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
