
		公式
		
			
				G - Delivery on Tree 解説
			
			by yuto1115
			
		
		解説
		
		
			まず、カゴが動く経路は全ての辺をちょうど \(2\) 回ずつ通り頂点 \(1\) に戻ってくるようなものに限定されていることから、経路を定めることは、子を \(2\) つ持つ各頂点についてそれらの子を訪れる順序を定めることと等価です。

各ボールを正しく移動させるために操作列に対して課される条件について考えます。まず、以下が定まります。


（条件 A）子を \(2\) つ持つ各頂点 \(i\) について、「左の子を先に訪れなければならない」「右の子を先に訪れなければならない」「どちらの子を先に訪れてもよい」のいずれであるか


具体的には、\(S_j\) と \(T_j\) の最小共通祖先 \(\text{lca}(S_j,T_j)\) が \(S_j\) とも \(T_j\) とも一致しないとき、\(\text{lca}(S_j,T_j)\) の子を訪れる順序に制約がかかります。これらの制約が矛盾を生じた場合、答えは明らかに \(0\) です。

次に、各ボールについてそのボールをカゴに入れる/カゴから出す最適なタイミングを考えることで、以下が定まります。


（条件 B）各頂点 \(i\) の各 \(c\in \{\)左の子\(,\)右の子\(,\)親\(\}\) について、「\(i\) から \(c\) に移動する直前にカゴに入れるボールの数」および「\(c\) から \(i\) に移動した直後にカゴから出すボールの数」


例えば、\(S_j\) が \(T_j\) の祖先であり、\(S_j\) の右の子が \(S_j-T_j\) パス上に存在する場合、\(S_j\) から \(S_j\) の右の子に移動する直前にボール \(j\) をカゴに入れ、\(T_j\) の親から \(T_j\) に移動した直後にカゴから出すのが最適です。

あとは、条件 A を満たす経路のうち、条件 B に沿ってボールを出し入れしたときにカゴの中のボールが \(K\) 個を超えないようなものの数を数えればよいです。これは以下の DP によって求まります。


\(dp[i][j]\) : \(j\) 個のボールがカゴに入った状態で頂点 \(i\) に初めて訪れたとき、


部分木 \(i\) 内の頂点を訪れる順番のうち、条件を満たすものは何通りあるか
部分木 \(i\) 内の頂点を全て訪れて \(i\) の親に戻るとき、カゴの中に入っているボールは何個か（なお、この値を \(j'\) としたとき、\(j'-j\) の値は \(j\) によらず一定です。）



遷移等は自然であり特筆すべき点はありませんが、実際のところこの問題の本質は実装です。以下の実装例では、実際には起こり得ない \((i,j)\) のペアに対して DP 値を計算しようとしたときに発生する煩雑さを省くため、メモ化再帰で実装しています。また、子の数による場合分けを避けるために順列全探索を用いています。

実装例 (C++) :



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
