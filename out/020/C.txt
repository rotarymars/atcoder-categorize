
壁抜け

1.問題概要
2.アルゴリズム

3/19/15

©AtCoder Inc. All rights reserved.

• 正方形のマスが縦H行、横W列に並んでおり、
各マスは白か黒。スタート・ゴールが白マスにある
• スタートからゴールに T 秒以内に到着したい。
上下左右に動けるが、白マスに移動するのに 1 秒、
黒マスに移動するのに x 秒かかる
• 目標を達成できるような x の最大値は？
• 2 ≦ H, W ≦ 10, 2 ≦ T ≦ 109
• 求める最大値が存在するような入力が与えられる
（1度は黒マスを踏まないとゴールできない、
かつ x = 1 なら間に合う）
3/19/15

• T 秒以内にゴールできるような x の最大値を
「直接」求めるのは難しそう
• x ≧ T のとき、T 秒以内のゴールは不可能
（一度は黒マスを踏む必要があるような入力が来る）
• 「この x の値で T 秒以内にゴール可能か？」を
x = T-1, T-2, … で調べ、最初に Yes となる x が答え
• このままでは満点 (T ≦ 109) は取れないが、
とりあえず 70 点まではこの方針で

3/19/15

• 部分点 1 (40 点): 2 ≦ H, W ≦ 3, 2 ≦ T ≦ 30
• ここまでマス目が狭いと、スタートからゴールまでの
経路をすべて列挙したところで大して多くはない
• 「この x で T 秒以内にゴール可能か？」の判定のため
DFS（深さ優先探索）などで経路をすべて列挙し、
T 秒以内にゴールする経路が存在するかチェック
• 計算量は実装によるが、実行時間が問題になるような
制約ではないはず

3/19/15

• 部分点 2 (計 70 点): 2 ≦ H, W ≦ 10, 2 ≦ T ≦ 30
• もはや経路の全列挙は不可能。最短経路を効率的に
求めるアルゴリズムが知られているので、それを使う
• ダイクストラ法、ベルマン-フォード法、
ワーシャル-フロイド法、… (「最短路問題」などで検索)
• 今回はマス目の数が 100 以下と少ないため、
T 回繰り返すことを考慮してもどれを使用しても可
(スクリプト言語でワーシャル-フロイド法は厳しいか)

3/19/15

• 満点 (100 点): 2 ≦ H, W ≦ 10, 2 ≦ T ≦ 109
• 「この x で T 秒以内にゴール可能か？」…☆ を
x = T-1, T-2, … とすべて調べることはもはや不可能
• 本当にこの順にすべて調べる必要はあるだろうか？
• x を小さくすると、最短経路も短くなる。従って、
x = i で ☆ の答えが Yes なら、x < i のときも Yes.
x = i で ☆ の答えが No なら、x > i のときも No.

3/19/15

• lo = 1, hi = T として、hi – lo = 1 となるまで
以下を繰り返すと、 lo に求めたい最大値が入る
mi = (lo + hi) / 2
if(x = mi のときT秒以内にゴール可能) then lo = mi
else hi = mi
• 1回のループで hi – lo がおよそ半分になるため、
9

9

T = 10 でも log2(10 ) = 30 周程度で終了する
• 「二分探索」と呼ばれる手法
• 別解もあります (x > H*W のときは黒を通る回数を最小化した上で白の回数を
最小化するべきで、数式で最大値を出す。ダメなら x ≦ H*W のときを全部調べる)
3/19/15

