
LCM Rush

1.問題概要
2.アルゴリズム

3/19/15

©AtCoder Inc. All rights reserved.


問題概要

• 整数 N, K が与えられる
• LCM(1, K) + LCM(2, K) + … + LCM(N, K) を
1,000,000,007 で割った余りを求めよ
（LCM(a, b) は a と b の最小公倍数）
• 1 ≦ N, K ≦ 109

3/19/15


アルゴリズム (部分点 1)

• 部分点 1 (5 点): 1 ≦ N, K ≦ 100
• i * K は i の倍数でも K の倍数でもあるから、
LCM(i, K) は i * K 以下
• 1 から i * K までの各整数について、小さい順に
i と K の両方で割っていき、最初に両方で
割り切れた数が LCM(i, K)
• これを 1〜N のすべてについて行う
• 時間計算量 O(N2 K)

3/19/15


アルゴリズム (部分点 2)

• 部分点 2 (計 15 点): 1 ≦ N ≦ 104, 1 ≦ K ≦ 100
• LCM(i, K) をもっと速く求めたい
• 「最小公倍数 プログラム」などで検索
• LCM(a, b) = a * b / GCD(a, b) という関係がある
（GCD(a, b) は a と b の最大公約数））
• 「ユークリッドの互除法」というGCDを高速に計算する
方法がある（計算量は O(log(2つのうち小さい方の数))）
が、今回は 1〜K を全部試しても可
• 時間計算量 O(N log(K)) または O(NK)
3/19/15


アルゴリズム (部分点 3)

• 部分点 3 (計 100 点): 1 ≦ N ≦ 109, 1 ≦ K ≦ 100
• もはや 1〜N をすべて列挙することができない
• 本当に列挙する必要があるのだろうか？
• 前述の通り LCM と GCD には深い関係があるが、
その GCD には GCD(i, K) = GCD(i % K, K)
という性質がある
（i % K は i を K で割った余り。
「ユークリッドの互除法」はこれに基づく）
• K で割った余りで 1〜N を分類したらどうか？
3/19/15


アルゴリズム (部分点 3)

• 分かりやすさのため具体例(N=53, K=10)で説明する
• 1〜53 のうち 10 で割って 2 余る数は
2, 12, 22, 32, 42, 52 の 6 個
• これらのどれを i としても GCD(i,10)=GCD(2,10)=2
• 従って、これらの各 i に対する LCM(i, 10) の和は
2*10/2 + 12*10/2 + … + 52*10/2
= (2 + 12 + … + 52) * 10 / 2
• 下線部は等差数列の和で、O(1)で求まる
（よく分からなければ検索。
計算例: ((最初の項) + (最後の項)) * (項数) / 2 ）
3/19/15


アルゴリズム (部分点 3)

• 同様に、 0〜K-1 のすべての整数 r について
「1〜N のうち K で割った余りが r であるような整数 I
すべてについての LCM(i, K) の和」を求めて合計する
• 時間計算量 O(K log(K))

3/19/15


アルゴリズム (満点)

• 満点 (101 点): 1 ≦ N, K ≦ 109
• K も N と同程度に大きいと、 1〜N を K で割った余りで
0〜K-1 に分類したところで計算量が減らない
• GCD(i, K) の値には相当数の重複が含まれないか？
• GCD(i, K) は K の約数の値しかとらず、
9

K ≦ 10 のとき K の約数は高々 1344 個
(K = 735134400 で最大)
• GCD(i, K) の値で 1〜N を分類したらどうか？
3/19/15


アルゴリズム (満点)

• 以下、 N = 41, K = 12 の具体例で説明する
• まず、GCD(i, 12) = 1 なるすべての i について
LCM(i, 12) を足しあわせたものを求めてみる
• LCM(1, 12) + LCM(5, 12) + LCM(7, 12) + …
= 1 * 12 / 1 + 5 * 12 / 1 + 7 * 12 / 1 + …
= (1 + 5 + 7 + …) * 12 / 1
• 下線部の和を効率よく求めたい

3/19/15


アルゴリズム (満点)

• GCD(i, 12) = 1 なるすべての i の和を効率よく求めたい
• 1〜N のすべての整数の和から
(1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 + 11 + 12 + 13 + …)

• 2 や 3 の倍数を引く （GCD(i, 12) = 1 を満たさない）
-(
-(

2

+4
3

+6
+6

+8

+ 10
+9

+ 12 + …)
+ 12 + …)

• すると 6 の倍数が二度引かれてしまうので足し直す
+(

+6

+ 12 + …)

• ここまでの式はいずれも O(1) で計算可
(1 + 2 + … + n = n(n+1)/2 を使うとよい)
3/19/15


アルゴリズム (満点)

• GCD(i, K) = 1 なる i すべてについての LCM(i, K) の
和が求まったが、 1 以外の K の約数についてはどうか
• 再び N = 41, K = 12 の具体例で考える。
GCD(i, 12) = 2 なる i (1 ≦ i ≦ 41) すべてについての
LCM(i, 12) の和を求める
• GCD(i, 12) = 2 のとき、 i = 2j (1 ≦ j ≦ 20) とおくと
GCD(i, 12) = GCD(2j, 12) = 2 * GCD(j, 6)
• 従って、「GCD(j, 6) = 1 なる j (1 ≦ j ≦ 20) すべてに
ついての LCM(j, 6) の和」の 2 倍を求めればよく、
GCD(i, K) = 1 のケースに帰着する
3/19/15


アルゴリズム (満点)

• 同様に、 K の約数 d すべてについて
「GCD(i, K) = d なる整数 i (1 ≦ i ≦ N)
すべてについての LCM(i, K) の和」を求めて合計する
• 各 d について「K/d の素因数全体の集合の部分集合
すべて」を列挙するので、時間計算量を大雑把に
見積もると、 f(n) を n の約数の個数、
g(n) を素因数の個数として O(f(K) * 2

g(K)

• K ≦ 109 のとき f(K) ≦ 1344, g(K) ≦ 9
• 実際にはより少ない計算量で求まる
3/19/15

* g(K))


おわりに

• お疲れ様でした。
• この問題は AtCoder Beginner Contest としては
規格外の難易度で、 AtCoder Regular Contest の
（が、典型的ではあると思います）
満点がとれた人は Beginner とは呼びがたいです。

3/19/15


