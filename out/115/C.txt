木の本数は最大で 10 万本とかなり多く、K も 2 以上 N − 1 以下の範囲で自由な値を取りうるため、例え
ば N = 100000, K = 50000 のとき飾る木の選び方の総パターン数は天文学的な数値になります*2 。したがっ
て木の飾り方の全パターンを 2 秒で調べることはできず、選択肢の数を減らす必要があります。
やや唐突ですが、仮に N 本の木が低い順に左から一列に並んでいたらどうでしょう？「飾った最も高い木」

(=飾った最も左の木) と「飾った最も低い木」(=飾った最も右の木) の高さをできるだけ近づけるには、ずば
り K 本の隣り合った木を飾るべきです。もしそうせずに飾った木と飾った木の間に飾っていない木があるな
ら、「間を詰める」ことにより状況が改善されるか、少なくとも悪くはならない*3 からです。
よって、仮に N 本の木が低い順に左から一列に並んでいた場合、「左から 1, 2, . . . , K 本目を飾る」
「2, 3, . . . , K + 1 本目を飾る」. . .「N − K + 1, N − K + 2, . . . , N 本目を飾る」という N − K + 1 通りの
パターンをすべて試せば十分です。それぞれのパターンにおける hmax − hmin の値も、最も高い木は最も右、
最も低い木は最も左にあるため簡単に求まります。
残る問題は、実際には N 本の木が低い順に入力されるとは限らないことです。これは与えられた木の高さ
を低い順に並び替えてしまえば (ソートすれば) 解決します。ほとんどの主要なプログラミング言語は標準機
*5
能として高速に動作する*4 ソートを備えているので、これを利用しましょう。

1

N, K = map(int, input().split())

2

h = [int(input()) for i in range(N)]

3

h.sort()

4

print(min(h[i+K-1] - h[i] for i in range(N-K+1)))

*2 252060836892200 . . . 通り (30101 桁)
*3 同じ高さの木が複数並んでいる場合
*4 長さ n の列に対し O(n log n) 時間で動作する
2
*5 ソートを「自前」で適当に実装してしまうと、N = 100000 のとき 2 秒以内に実行が終わりません。高速に動作するソートの実

装は AtCoder Beginner Contest の範囲を超えた課題で、興味があれば Wikipedia などが参考になるでしょう。

3

