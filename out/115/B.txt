「N 個の商品の定価の合計」を S 円、
「N 個の商品のうち最も定価が高いものの定価」を M 円とすると答
えは S − M/2 で、この S と M を実際に求めてみよという問題です。
この問題が A: Christmas Eve Eve Eve より難しいのは、商品の個数が 2 個や 3 個などと固定されておら
ず、N 個 (2 ≤ N ≤ 10) と可変であるためです。これに対応すべく、何らかの「ループを生む機構」を使うこ
とになります。代表例が for 文で、この内部で足し算や大小比較を行うことで S や M が求められます。

S を求めるためのより具体的な手順を述べると、まず S という値を宣言して 0 で初期化します。そして
i = 1, i = 2, . . . , i = N のそれぞれに対して S に pi を足すと、最終的に S に求めたい値が入ります。M に
ついても同様で、最初に M という値を 0 で初期化し*1 、
「M と pi を比較して pi の方が大きければ M を

pi に置き換える」ことを繰り返せば求まります。これを C++ で実装したコードが以下です。

1

#include <algorithm>

2

#include <iostream>

3

using namespace std;

4

int main(){

// max

5

int N;

6

cin >> N;

7

int S = 0, M = 0;

8

for(int i = 0; i < N; ++i){

9

int p;

10

cin >> p;

11

S += p;

12

M = max(M, p);

// M と p のうち大きい方。かなり便利! ちなみに小さい方は min

13

}

14

int ans = S - M / 2;

15

cout << ans << endl;

16

// ここでは商品番号を 0, 1, ..., N-1 とする

}
言語によっては、純粋な for 文以外の機構も便利です。以下のコード (Python3) をご覧ください。

1

N = int(input())

2

p = [int(input()) for i in range(N)]

3

print(sum(p) - max(p) // 2)

*1 すべての pi より小さい値なら 0 でなくても可

2

