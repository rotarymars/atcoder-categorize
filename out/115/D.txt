「レベル i バーガーの厚さ (層の総数)」を ai 、
「レベル i バーガーに含まれるパティの総数」を pi とします

(i ≥ 0)。これらの値は a0 = 1, ai = 2ai−1 + 3 (i ≥ 1), p0 = 1, pi = 2pi−1 + 1 (i ≥ 1) と順次求められます。
求めるべき数、「レベル N バーガーの下から X 層に含まれるパティの枚数」を f (N, X) と書きます。

N = 0 の場合は問題ないので、N ≥ 1 の場合を考えましょう。N = 0 の場合が問題ないことを活用して、
「レ
ベル N − 1 バーガーについてなら何を聞かれてもわかる。つまり、どんな整数 Y を指定されても f (N − 1, Y )
を知れる」と仮定してみると、次のようにレベル N バーガーについても何を聞かれてもわかってしまいます。

1. X = 1 のとき: f (N, X) = 0 (一番下のバンだけ)
2. 1 < X ≤ 1 + ai−1 のとき: f (N, X) = f (N − 1, X − 1)
(一番下のバン + その上のレベル N − 1 バーガーの下から X − 1 層)
3. X = 2 + ai−1 のとき: f (N, X) = pi−1 + 1
(一番下のバン + その上のレベル N − 1 バーガー + その上のパティ)
4. 2 + ai−1 < X ≤ 2 + 2ai−1 のとき: f (N, X) = pi−1 + 1 + f (N − 1, X − 2 − ai−1 )
( (前略) + その上のパティ + その上のレベル N − 1 バーガーの下から X − 2 − ai−1 層)
5. X = 3 + 2ai−1 のとき: f (N, X) = 2pi−1 + 1
( (前略) + その上のパティ + その上のレベル N − 1 バーガー + その上のバン)
これをそのまま再帰関数として実装すれば、N + 1 回以下の計算ステップで答えが求まります。

1

N, X = map(int, input().split())

2
3

a, p = [1], [1]

4

for i in range(N):

5

a.append(a[i] * 2 + 3)

6

p.append(p[i] * 2 + 1)

7
8
9
10
11
12
13
14

def f(N, X):

# X <= 0 や X > a_N を許容し解説本文から簡略化

if N == 0:
return 0 if X <= 0 else 1
elif X <= 1 + a[N-1]:
return f(N-1, X-1)
else:
return p[N-1] + 1 + f(N-1, X-2-a[N-1])

15
16

print(f(N, X))

4


