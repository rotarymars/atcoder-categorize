
		公式
		
			
				D - LRUD Instructions 解説
			
			by leaf1415
			
		
		
		
		
			まず、


各 \(i = 1, 2, \ldots, H\) について「 \(i\) 行目にあるすべての壁の位置を列の昇順に並べた配列 \(A_i\) 」
各 \(j = 1, 2, \ldots, W\) について「 \(j\) 列目にあるすべての壁の位置を行の昇順に並べた配列 \(B_j\) 」


を作ります。

ただし、\(H, W\) は非常に大きくなりうるため、すべての行 \(i\) と列 \(j\) について配列 \(A_i\) と配列 \(B_j\) を陽に作ると計算量が大きくなってしまいます。
そこで、連想配列を用いるなどの方法によって、壁を \(1\) 個以上含む行 \(i\) や列 \(j\) についてのみ、配列 \(A_i\) や配列 \(B_j\) を陽に構築します。

各指示では、高橋君は \(l_i\) マス進み終わるか、壁・グリッドの端にぶつかるまで移動を続けます。
よって、指示を実行した後の最終的な高橋君の位置を求めるには、
\(d_i\) の方向にある最も近い壁・グリッドの端の位置が分かれば良いです。
これは、適切な \(A_i\) や \(B_j\) 上で二分探索をすることで \(\mathrm{O}(\log N)\) 時間で求めることができます。

例えば、高橋君の現在位置がマス \((R, C)\) のときに左向きに移動する指示を実行することを考えます。
このときの進行方向にある最も近い壁の位置（列番号）は \(A_R\)上で \(C\) 以下の最大の要素です。ただし、\(C\) 以下の要素が存在しないときは、進行方向においてグリッドの端までの間に壁はないとわかります。
\(A_R\) は事前に昇順にソートしてあるので、\(C\) 以下の最大の要素（あるいはそれが存在しないこと）は二分探索で求めることができます。

以上より、各指示を \(\mathrm{O}(\log N)\) 時間で実行できるので、指示全体で \(\mathrm{O}(Q \log N)\) 時間で実行できます。
\(A_i\) や \(B_j\) を作る時間（各要素を行・列の昇順にソートする時間など）を加味しても、本問題を \(\mathrm{O}((N+Q)\log N)\) 時間で解くことができます。

以下に、C++ 言語による本問題の正解例を記載します。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
