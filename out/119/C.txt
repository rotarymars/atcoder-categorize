竹の数は 8 本までと少ないですが、それでも三種類の魔法による行動パターンの総数は極めて多いです。
しかし、足し算の結果は順序を入れ替えても変わらないため、例えば「竹 X に延長魔法→竹 Y に延長魔法
→竹 X, Y に合成魔法を使用して竹 XY とする→竹 XY に延長魔法」という一連の行動は、「竹 X, Y に合
成魔法を使用して竹 XY とする→竹 XY に延長魔法を 3 回」という一連の行動と同等です。
このように、「以後合成魔法を使用しないような竹に対してのみ延長・縮小魔法を使用する」ような行動パ
ターンのみを考えると、可能な行動パターンを本質的にすべて列挙することが可能になります。
具体的には、竹 1, 2, . . . , N のそれぞれに対し、その竹の扱いは本質的には次の 4 通りに限られます:「長さ

A の竹の “材料” とする」「長さ B の竹の材料とする」「長さ C の竹の材料とする」「使わない」。この合計
4N 通りの竹の扱い方をすべて試行します (最大で 48 = 65536 通りで、この数は十分現実的です)。
ただし、“無” に対して延長魔法を使って竹を得ることはできないことに注意します。すなわち、「長さ A
の竹の材料」
「長さ B の竹の材料」
「長さ C の竹の材料」がそれぞれ一本以上必要で、これを満たさない竹の
扱い方は棄却します。
上記の条件を満たす竹の扱い方に対しては、その場合の「長さ A の竹の材料」をすべて合成して竹を得て、
延長魔法と縮小魔法のうち適切な方を適切な回数だけ使って長さ A の竹を得るためのコストを計算します。
長さ B, C の竹についても同様に得るためのコストを計算して合計すれば、その竹の扱い方で達成できる最小
のコストを計算できます。以上を 4N 通りすべての竹の扱い方に対して行って得られた最小値が答えです。

1

N, A, B, C = map(int, input().split())

2

l = [int(input()) for i in range(N)]

3

INF = 10 ** 9

4
5
6
7

def dfs(cur, a, b, c):
if cur == N:
return abs(a - A) + abs(b - B) + abs(c - C) - 30 if min(a, b, c) > 0 else INF

8

ret0 = dfs(cur + 1, a, b, c)

9

ret1 = dfs(cur + 1, a + l[cur], b, c) + 10

10

ret2 = dfs(cur + 1, a, b + l[cur], c) + 10

11

ret3 = dfs(cur + 1, a, b, c + l[cur]) + 10

12

return min(ret0, ret1, ret2, ret3)

13
14

print(dfs(0, 0, 0, 0))

3

