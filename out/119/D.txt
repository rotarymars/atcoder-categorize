一つの問い xi について考えましょう。地点 xi より西にある神社のうち最も東にある神社を sa 、xi より東
にある神社のうち最も西にある神社を sb とします。もとの設定のままでは神社 sa , sb のいずれかが存在しな
い可能性がありますが、道路のはるか西とはるか東、訪れる価値がないような位置 (例えば、道路の西端から

1018 メートル西と 1018 メートル東) にも神社があるとすると神社 sa , sb はどちらも必ず存在します。
このとき、道路上に sa , sb 以外の神社は存在しないとしても答えは変わりません。なぜなら、もしその他の
神社 so を訪れることがあれば、その過程ですでに sa , sb のいずれかを通過しているはずで、so をあえて訪れ
る必要はないためです。同様に寺 tc , td を定義すると、それら以外の寺は存在しないとしても答えは変わりま
せん。よって、sa , sb , tc , td のうちどれをどの順に訪れるかの選択 8 通り*1 をすべて試せば答えが求まります。
あとは、sa , sb , tc , td をどのように高速に求めるかが課題です。b が求められれば、a = b − 1 であり c, d も
同様に求められるため、以下では b を求めることを考えます。

b をより数学的に定義すると「sj > xi であるような最小の整数 j 」となります (s1 , . . . , sA がはじめから昇
順に並んでいることに注意)。このような値を高速に求めるアルゴリズムに 二分探索 (リンク先は Wikipedia
の同名の記事) があり、現代の多くの言語に標準で実装されています。これを用いると、⌈log2 (A + 2)⌉ ステッ
*3
プ*2 の演算で b を求めることができ、10 万個の問いに対しても十分高速です。

1

import bisect

2

A, B, Q = map(int, input().split())

3

INF = 10 ** 18

4

s = [-INF] + [int(input()) for i in range(A)] + [INF]

5

t = [-INF] + [int(input()) for i in range(B)] + [INF]

6

for q in range(Q):

7

x = int(input())

8

b, d = bisect.bisect_right(s, x), bisect.bisect_right(t, x)

9

res = INF

10

for S in [s[b - 1], s[b]]:

11

for T in [t[d - 1], t[d]]:

12

d1, d2 = abs(S - x) + abs(T - S), abs(T - x) + abs(S - T)

13

res = min(res, d1, d2)

14

print(res)

*1 sa → tc , sa → td , sb → tc , sb → td とこれらの逆順。これらの中には通り過ぎた寺社に戻ってくるような無意味な歩き方もあり

ますが、最適解を求める上で害はありません
*2 ⌈x⌉ は x 以上の最小の整数です。なお、数式中の “+2” は西の果てと東の果てに足した神社に対応します
*3 ただし “遅い” 言語ではあまり余裕がなく、上記のコードも最適化が甘くかろうじて間に合う程度です

4


