
		公式
		
			
				C - Made Up 解説
			
			by KoD
			
		
		
		
		
			\(i\) を固定したときに、\(A_i = B_{C_j}\) となる \(j\) の個数が高速に求められればよいです。これを前もって計算しておく方法を考えます。

\(B_k\) の値は \(1\) 以上 \(N\) 以下であるので、長さ \(N\) 程度の配列 \(\mathrm{count}_x\) を用意し、\(j\) の値を全て試すことによって、各 \(1 \leq x \leq N\) について \(B_{C_j} = x\) となる \(j\) の個数を \(\mathrm{count}_x\) として保持しておくことが出来ます。

各 \(i\) について \(\mathrm{count}_{A_i}\) を足し合わせたものが答えとなります。答えは最大で \(N^2\) になるため、\(32\) bit 整数に収まらないことに注意してください。

このように、「同じような処理を何度も行う」ような問題においては、「前もって計算しておく」という方法がうまくいくことがしばしばあります。

C++ での実装例：



Rust での実装例：



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
