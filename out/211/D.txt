
		公式
		
			
				D - Number of Shortest paths 解説
			
			by kyopro_friends
			
		
		
		
		
			まずは頂点 \(1\) から頂点 \(N\) までの最短距離を求める問題を考えてみましょう。辺の重みが全て \(1\) であることから、この問題はBFS(幅優先探索)を用いることで \(O(N+M)\) で解くことができます。

元の問題も同様に、BFSを用いて \(O(N+M)\) で解くことができます。始点からの距離だけでなく、それを達成する経路の数も同時に計算します。

最短距離を求めるBFSでは、最短距離を表す配列を\(\text{dist}\) として


\(v\) から遷移できる各 \(v'\) に対して次を行う


\(v'\) に未到達なら \(\text{dist}[v']\) を \(\text{dist}[v]+1\) に更新
そうでないなら何もしない



という処理をしますが、最短経路の数を表す配列 \(\text{cnt}\) を新たに用意することで、次のように更新することができます。


\(v\) から遷移できる各 \(v'\) に対して次を行う


\(v'\) に未到達なら \(\text{dist}[v']\) を \(\text{dist}[v]+1\) に更新し、\(\text{cnt}[v']\) に \(\text{cnt}[v]\) を代入する
\(v'\) に到達済みかつ \(\text{dist}[v']=\text{dist}[v]+1\) なら、\(\text{cnt}[v']\) に \(\text{cnt}[v]\) を加算する
そうでないなら何もしない



実装例(Python)



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
