問題は次のように言い換えられます．





N 個の頂点と M 本の有向辺からなるグラフがあります．辺 i は頂点 xi から頂点 yi へ張ら
れています．N 個の頂点を横一列に並べます．このとき，各有向辺は左から右へ向かうよう
にします．頂点の並べ方は何通りでしょうか？





有向グラフが与えられたとき，上の条件を満たすように頂点を並べることを，トポロジカルソー
ト といいます．よって，この問題はトポロジカルソートの方法の数え上げということになります．
この問題は難しい問題として知られていますが，N が小さければ解くことができます．

部分点解法
N ≤ 8 なので，N 個の頂点の並べ方を全探索することができます．それぞれの並べ方について，
M 本の有向辺が左から右へ向かっているか判定すればよいです．最大のステップ数を見積もると，
N ! × M ≈ 1.1 × 106 と十分小さいことが分かります．なお，順列を全探索するには，たとえば
2

C++ では std::next permutation 関数が便利です．

満点解法
N ≤ 16 なので，N 個の頂点の並べ方を全探索することはできません．そこで，動的計画法
(DP) によって解くことを考えます．
全頂点集合を U := {0, 1, . . . , N − 1} とします．それぞれの頂点集合 S ⊆ U に対して，

f (S) := (頂点集合 S をトポロジカルソートする方法の通り数)
と定義します．f (ϕ) = 1 であり，また f (U ) が求めたい答えです．これらの間を繋ぐ漸化式を立
ててみましょう．頂点集合 S をトポロジカルソートするとき，頂点 v ∈ S が最も右に置かれるた
めの必要十分条件を考えてみます．これは，頂点 v から頂点集合 S − {v} へ向かう有向辺がない
という条件になります．この条件を満たす頂点の集合を XS (⊆ S) と書くことにします．つまり，

XS := {v ∈ S

| v から S − {v} へ向かう有向辺がない }

と定義します．すると，f (S) の漸化式は次のようになります．

{
1
f (S) = ∑

(S = ϕ)
v∈XS f (S − {v}) (otherwise)

この漸化式に従って各 f (S) を計算すれば，f (U ) が答えです．
以降は，実装上のテクニックを紹介します．プログラム上で頂点集合 S を表現する際は，二進
数を使うのが便利です．頂点集合 S が頂点 i を含むならば第 i ビットを 1 とし，頂点 i を含まな
いならば第 i ビットを 0 とします．たとえば，N = 5 で S = {0, 1, 3} ならば，対応する二進数は

01011 となります．こうすることで，頂点集合 S と整数のインデックスを対応付けることができ，
f (S) の値を配列に格納することができます．さらに，各 f (S) を計算する際には，二進数の値が
小さい方から順に計算していけばよいことが分かります．以上のテクニックを使った DP は特に

bit DP と呼ばれています．
最後に，計算時間を見積もりましょう．最大のステップ数を見積もると，2N × M ≈ 7.9 × 106
と十分小さいことが分かります．このように，N ! は大きすぎるが 2N は小さい場合，bit DP が
想定解であることはよくあります．

3


