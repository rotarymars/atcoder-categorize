
		公式
		
			
				E - LEQ 解説
			
			by penguinman
			
		
		
		
		
			\(A\) の要素が互いに異なると仮定したとき、任意の整数 \(i,j\ (1 \leq i \lt j \leq N)\) について以下が成り立ちます。


\(A'_1=A_i\) かつ \(A'_k=A_j\) が成り立つような \(A\) の連続するとは限らない部分列 \(A'=(A'_1,A'_2,\ldots,A'_k)\) は、\(2^{j-i-1}\) 個存在する。


故に、\(A\) の要素が互いに異なると仮定した場合答えは以下の通りになります。


\(1 \leq i \lt j \leq N\) かつ \(A_i \leq A_j\) を満たすすべての整数対 \((i,j)\) に対する、\(2^{j-i-1}\) の総和


\(2^{j-i-1}=\frac{2^{j-1}}{2^i}\) より、以下のことが分かります。


\(j=1,2,\ldots,N\) について、\(B_j=(1 \leq i \lt j\) かつ \(A_i \leq A_j\) を満たすようなすべての整数 \(i\) に対する、\(\frac{1}{2^i}\) の総和\()\) と定義する。このとき、答えは \(\sum_{j=1}^{N} B_j \times 2^{j-1}\) である。


よって \(j=1,2,\ldots,N\) について \(B_j\) が求められてさえいれば、答えを求めることは容易です。

\(B_j\) を求めること自体はそこまで難しくはなく、\(A\) の要素を座標圧縮した上で Binary Indexed Tree 等を用いて添字の昇順に走査していくことで \(O(N \log N)\) で求値可能です。ここで \(\frac{1}{2^i}\) を小数等で管理するのは困難であるため、\(\text{mod}\ 998244353\) 上での逆元を用いて管理することが推奨されます。

\(A\) の要素が互いに異ならない場合においても、似たような手法により答えを求めることが可能です。よってこの問題を解くことができました。

計算量は実装により \(O(N \log N)\) や \(O(N \log \text{mod})\) となります（後者は逆元の計算を毎回行った場合の計算量）。

実装例 (C++)



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
