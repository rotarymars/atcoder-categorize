
		公式
		
			
				C - Keys 解説
			
			by physics0523
			
		
		
		
		
			制約より \(N \le 15\) と鍵の本数が少ないです。さらに、 \(M \le 100\) とテストの回数もそう多くありません。
また、問題文に記載のある通り、本物かダミーかの組み合わせとして考えるべきものの数は \(2^N\) 通りです。

この \(2^N\) 通り全てに対して \(M\) 回のテストを行い、矛盾しなかった組み合わせの数を数えれば良いです。
このとき必要なテストの総回数は \(2^N \times M \le 3.3 \times 10^6\) であり、全てのテストに一回当たり \(N\) 回の演算をかけても演算回数は \(5 \times 10^7\) 回以下と見積もられ、これはこの問題に正解するのに十分高速です。

\(2^N\) 通りの組み合わせを簡単に全探索するには、 bit全探索 が便利です。

例えば \(i=0,1,\dots,2^N-1\) について for ループを回し、 \(i\) の \(2^k\) の位が \(0\) なら \(k+1\) 個目の鍵はダミーで、 \(1\) なら \(k+1\) 個目の鍵は本物と対応付けることで全探索が可能です。

bit 全探索について、詳しくは以下の記事を参考にしてください。


bit全探索について簡単にまとめる
こわくないbit全探索1 入門編: bit全探索ってなに？【競プロ解説】
bit 全探索
競技プログラミング講習/bit全探索
3.05.ビット演算


注意として、一回のテストに \(N^2\) 回程度の演算をかけてしまうと実行時間制限に間に合わない可能性があります。
バケットソートの要領で \(k\) 番目の鍵を使ったかどうかを管理するなどして一回のテストの演算回数を \(N\) 回以内に抑えてください。

実装例 (C++):



bit演算を駆使した実装は次の通りです。
上記の実装例より高速に動作します。

実装例 (C++):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
