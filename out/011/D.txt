1. 問題概要
2. アルゴリズム

2014/6/21

©AtCoder Inc. All rights reserved.

23


• ランダムな4方向に、距離Dだけジャンプする
• N回のジャンプ後に、ゴール地点(X,Y)にいる確率を
出力しなさい。
• 制約
– 1≦N≦ 8(part1) , 30(part2), 1000(all)
– 1≦X,Y,D≦10^9

2014/6/21

24


• 前処理
– ジャンプの距離がDなのは面倒！1にしたい！
• X /= D; Y /=D;しましょう。
• 割り切れなかったら、確実に(X,Y)にはたどり着けないので、答え
は0です。

2014/6/21

25


• 全探索について
– 4方向に移動するので、パターン数は4 ^ N
– 部分点1の制約なら、4^8は65536なので、計算可能
• 全パターン調べて、(X , Y)に辿り着いたパターン数を、4^Nで割れ
ば良い。

– では、どうやって全パターンを調べるのか？
• 深さ優先探索を使おう！

2014/6/21

26


• 深さ優先探索
– 再帰を利用して、全パターンを列挙する
• Int dfs(int count, int nowX, int nowY)みたいな関数を作る
– CountがNであれば、X==nowX, Y==nowYの時に、1を返す
» それ以外は0を返す

– CountがN以外であれば、4方向について探索する
» dfs(count+1, nowX + 1, nowY);
» dfs(count+1, nowX - 1, nowY);
» dfs(count+1, nowX, nowY + 1);
» dfs(count+1, nowX, nowY - 1);
» Forループで書ける形にするとちょっと楽。

– この4つの結果を足し算した値をreturnする。

– 幅優先探索などでも良いが、深さ優先探索の方が書き易
い
2014/6/21

27


• N = 30だと？
– 深さ優先探索を単純にするだけでは、計算が間に合わな
い。
• 何か工夫をしなければならない。

– 「上、右」と移動した後と、「右、上」と移動した後で、X,Yに
辿り着く確率は同じはず。
• こうしたものを、上手く纏めることによって、計算を早くしよう！

2014/6/21

28


• メモ化再帰を使った高速化
– dfs(count, nowX, nowY)のような関数を作った。
– N = 30の時、これの取り得る値は？
• Count は、0～N
• nowX は、-N～N
• nowYは、-N～N
• ということは、O(N^3)通りしか、パターンが存在しない！
– よって、これらの計算結果をメモしてあげることで、高速に計算する
ことが出来る！
– 計算結果をまとめただけで、O(4^N)からO(N^3)まで変わる。

2014/6/21

29


• メモ化再帰って？
– DFSの計算結果をメモしておく手法！
– 下のような一文を、冒頭に入れる！
• If(dp[count, nowX, nowY] != -1) return dp[count, nowX, nowY] ;

– 答えを返す時に、以下のように答えをメモする！
• ret = …. （こたえ）
• return dp[count, nowX, nowY] = ret ;

– これだけで、同じ引数でdfs関数が呼び出された時に、2回
目からは一瞬で答えを返せるようになります。
• 今回の場合は、nowX, nowYが負の数になるので、配列を使う場
合は注意！
– X +=N, Y+=Nとしておけば、スタート地点をN,NにすればOK

2014/6/21

30


• N≦1000だと？
– でかい。動的計画法を使ったところで間に合わない。
– 仕方がないので、数学的に上手く計算してあげる必要が
ある！
• とはいっても、直接的に計算するのは難しい。

– 「上か下に移動する回数」と「左か右に移動する回数」に
分ければ計算できないか？

2014/6/21


• N = 1000, X = 10, Y = 20の時
– 例えば、「左右に動くのは600回」とする
• とすると、「上下に動くのは400回」とわかる

– 左右、上下の２択に分けたとして、左右に動くのが600回
な組み合わせは、1000C600通り
– ここで、「左に動くのは295回、右に動くのは305回」と解る
• なぜなら、600回の動きでX=10に辿り着くにはこれしかありえない
• (600 + 10) / 2 = 305のような形で求められる。

– この組み合わせは、600C295通り
– 同様に、上に動く回数、下に動く回数と、その組み合わせ
を計算出来る
– これらを全て掛ければ、「左右に動く回数がK回の時の、
X,Yに辿り着けるパターン数」が計算できる
2014/6/21


• K回左右に動くときのパターン数が計算可能
– であれば、Kを0からNまでループさせてあげれば、全ての
パターン数を計算することが可能！

• これを利用すれば、解くことが出来る！

2014/6/21


• 注意点
– Double型は実は10^308までしか入らない！
• なので、「全てのパターン数」を計算するのはやめたほうが良い。
– long doubleとか使えば大丈夫？ダメ！！！

• 「全パターン中、この組み合わせが選ばれる確率」も計算可能な
ので、そちらで上手く計算しよう！
– nCk / 2^Nみたいな感じ。
– パスカルの三角形を使って計算するのがお勧め。

2014/6/21

34


• パスカルの三角形を使ったCombinationの計算の仕
方！
– 「１個上の数」と、「１個上、１個左の数」を足し算する
– すると、i行目j番目の数字が、iCjになっている。
–1
– 11
– 121
– 1331
– 14641

2014/6/22

35


• パスカルの三角形を使った確率の計算の仕方！
– 「１個上の数」と、「１個上、１個左の数」を足し算する
• これを2で割る

– すると、i行目j番目の数字が、iCjになっている。
–1
– 0.5
0.5
– 0.25
0.5
0.25
– 0.125 0.375 0.375 0.125
– ……

• N個を選ぶ全ての組み合わせ中、K個を選ぶ組み合
わせの割合などを計算する時に便利！
2014/6/22

36


