数列 A に対し、A の先頭 i 項の和を Bi とします。なお、便宜上 B0 = 0 としておきます。
いま、Al + ... + Ar = Br − Bl−1 であり、Al + ... + Ar が M の倍数であることは Br , Bl−1 を M で割った
あまりが等しいことと同値です。よって、数えるべきは、Bi , Bj が mod M で等しいような 0 ≤ i < j ≤ N
の組の個数です。
これは、各 x = 0, ..., M − 1 について、Bi を M で割ったあまりが x であるような i の個数を求めておく
ことで計算可能です。M は大きいので長さ M の配列を持つことはできませんが、平衡二分木 (C++ なら

std::map) やハッシュマップ (C++ なら std::unordered map) を用いることで「Bi を M で割ったあまりが
x であるような i が存在するような x」についてのみ値を持っておくことができます。この工夫を用いれば計
算量が (O(N log N ) や乱択 O(N ) 時間に) 改善でき、この問題を解くことができます。

2


