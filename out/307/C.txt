
		公式
		
			
				C - Ideal Sheet 解説
			
			by mechanicalpenciI
			
		
		
		
		
			まず、先にシート \(C\) から切り出す範囲を決めておいてもシート \(X\) を作る事ができるかは変わりません。

そこで、まずシート \(C\) のマス目に座標をつけます。
切り出す \(H_X\times W_X\) の領域の左上のマスを \((0,0)\) とし、そこから \(a\) 行下かつ \(b\) 列右のマスを \((a,b)\) で表します。ただし、\(a,b\) が負の時はそれぞれ、 \(\lvert a\rvert\) 行上, \(\lvert b\rvert\) 列左を表すものとします。すなわち、\(0\leq i\leq a-1\), \(0\leq j\leq b-1\) をみたす \((i,j)\) からなるマス目を切り出します。これを領域 \(D\) とします。

解法 \(1\)

さて、シート \(A\) を貼る領域について考えます。
シート \(A\) は黒マスを含み、領域 \(D\) はシート \(A\) 上の黒マスを全て含む事からシート \(A\) を貼る領域と領域 \(D\) は \(1\) マス以上共有している必要があります。よって、シート \(A\) の左上のマスを貼り付ける先の(シート \(C\) 上の)マスとしてあり得るのは、
\((i,j)\) \((-H_A+1\leq i\leq H_X-1, -W_A+1\leq i\leq W_X-1)\) となります。
同様に、シート \(B\) の左上のマスを貼り付ける先の(シート \(C\) 上の)マスとしてあり得るのは、
\((i,j)\) \((-H_B+1\leq i\leq H_X-1, -W_B+1\leq i\leq W_X-1)\) となります。

それぞれのシートについて貼る位置を決めた時、問題文中の \(2\) つの条件がみたされているかは、\(H_A\times W_A\), \(H_B\times W_B\) のマス目においてすべての黒マスの貼った先が領域 \(D\) に含まれているか、 \(H_X\times W_X\)のマス目が目標としているシート \(X\) と一致しているかを確認するだけで良いです。

シート\(A,B\) を貼る場所の候補はそれぞれ \(19\times 19\) 通り、
条件をみたしているか判定するために調べる場所はのべ \(3\times(10\times 10)\) マスである事から、全体で \((19\times 19)^2\times 300\) 回となり、十分時間内に間に合います。
よって、この問題を解く事ができました。

なお、実装においては、細かい実装方針にもよりますが、


配列のindexは多くの言語において非負であることが好ましいため、切り出す領域の左上のマスを \((10,10)\) とする。
マス目の大きさに依存しない形にするため、シート \(A,B,X\) に必要ならば透明なマスのみからなる行, 列を加えてつねに \(10\times 10\) のマス目とみなす。


といった工夫をすると実装が楽になるかもしれません。

解法 \(2\)

シート \(A,B,X\) の黒マスのうち、それぞれのシートの黒マスの中で最も上の行に属し、その中で最も左にあるマスを各シートの良い黒マスとすると、条件をみたすように切り出せた時、シート \(X\) の良い黒マスに対応するマスには シート \(A\) または \(B\) の良い黒マスが貼り付けられていることになります。良い黒マスを一致させるために貼らなければならない場所は一意に定まるため、シート \(A\) の黒マスと一致する時、シート \(B\) の黒マスと一致する時のそれぞれについて、もう一方のシートを貼る場所の候補をすべて試せば良いです。(下の実装例では実装の都合上右下のマスを良いマスとしています。)

この時、比較回数は全体で \(2\times (19\times 19)\times 300\) 回となり、より高速です。

c++ による実装例 \(1\) (解法 \(1\)):



c++ による実装例 \(2\) (解法 \(1\)):



c++ による実装例 \(3\) (解法 \(2\)):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
