0 ≤ X ≤ K なる X 全てについて f (X) を計算し、最大値を出力する方法では、O(N K) となり計算に 10
年以上かかりそうです。そこで、より高速に求める必要があります。

X < K + 1 なので K + 1 = (K39 K38 ...K0 )2 , X = (X39 X38 ...X0 )2 と 2 進数で表したとき*1 に、
X39 = K39
..
.
Xi+1 = Ki+1
Xi < Ki

を満たす i が存在します。このとき、Xi = 0, Ki = 1 です。
逆に、ある i について

X39 = K39
..
.
Xi+1 = Ki+1
Xi < Ki

であるような X は、Xi−1 , Xi−2 , ..., X0 の値に関わらず X < K が成り立ちます。
そこで、このような i(0 ≤ i < 40) を全探索することを考えます。各 i に対する f (X) の最大値を ai とす
れば、解は max{a0 , a1 , ..., a3 9} になります。
各 i に対する f (X) の最大値を考えます。X39 , X38 , ..., Xi は条件より

X39 = K39
..
.
Xi+1 = Ki+1
Xi = 0

です。上でも述べたとおり Xi−1 , Xi−2 , ..., X0 を決める際には X < K を無視しても構いません。f は
ビットごとに考えることができるため、Xi−1 , Xi−2 , ..., X0 を独立に決めることができます。具体的には、

Xk (0 ≤ k ≤ i − 1) について、A1 , A2 , ..., AN の中で下から k ビット目が立っているものの数を ck とすると、
Xk = 0 とすればこのビットが f に貢献する値は 2k ck となり、Xk = 1 とすれば 2k (n − ck ) となります。し
たがって、ck > n − ck の場合は Xk = 0 とし、そうでない場合は Xk = 1 とするのが最適です。これを i の
小さい順または大きい順に探索することで、X を高々 2 ビットずつ変化させて探索でき、O(N logK) で求め
ることができます。
別解として、X の上位ビットから順に決める桁 DP による O(N logK) の解法もあります。
*1 制約 X, K ≤ 1012 ≤ 240 より X, K は 40 ビットで表せます。

4


