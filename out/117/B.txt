最大の Li が他の Li の和未満であれば ‘Yes‘、そうでなければ ‘No‘ を出力すれば良いことが問題文の定理
からわかります。したがって、「最大の Li 」と「他の Li の和」を求められれば判定することができます。こ
れらを求めるアプローチはいくつかあります。
方法 1

L を昇順にソートします。すると、始めの N − 1 要素の和が「他の Li の和」、最後の要素が「最大の
Li 」となります。
方法 2

Lj が最大となる j を求めます。これは、仮に j := 1 として、L2 > Lj ならば j := 2 と更新し、
L3 > Lj ならば j := 3 と更新し、・・・と繰り返すことで求められます。すると、j ̸= k なる k につ
いて Lk を足し合わせたものが「他の Li の和」、Lj が 「最大の Li 」となります。
方法 3
まず、最大値を求めます。これは、方法 2 やそれと似た方法でできます。次に L1 , L2 , ..., LN の合計を
求め、S とします。すると、S − Lj が「他の Li の和」
、Lj が 「最大の Li 」となります。
これを C++ で実装すると、次のようになります。

# include < bits / stdc ++. h >
using namespace std ;
int main () {
int n ; cin >> n ;
int sum = 0 , maxL = 0;
for ( int i = 0; i < n ; ++ i ) {
int L ; cin >> L ;
sum += L ;
maxL = max ( maxL , L );
}
if ( maxL < sum - maxL ) {
cout << " Yes " << endl ;
}
else {
cout << " No " << endl ;
}
}

2

