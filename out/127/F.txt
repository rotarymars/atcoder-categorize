∑N
N 個の関数が与えられており、f (x) = i=1 (|x − ai | + bi ) となっている時を考えます。まず、f (x) =
∑N
∑N
∑N
i=1 |x − ai | +
i=1 bi と分解でき、項
i=1 bi は定数であるため、最小値を考える際には影響を与えない
∑N
∑N
事が分かります。よって、 i=1 |x − ai | の最小値を与える x を求め、その最小値に i=1 bi を足したものを
出力すれば良いです。
以下、簡単のため、{ai } が昇順に整列されていると仮定し、a0 = −∞, aN +1 = ∞ とおくことにします。

∑N

i=1 |x − ai | の最小値はどのようにして求めれば良いでしょうか？今、i 番目の絶対値関数 |x − ai | は

x < ai において傾き −1 の 1 次関数、x > ai において傾き 1 の 1 次関数になっています。1 次関数同士を足
し合わせても 1 次関数になる事を考えると、i = 0, · · · , N それぞれにおいて、区間 [ai , ai+1 ] 内で f (x) は 1 次
関数と見做すことができます。
更に、x が小さいほど、N 個の関数の内、傾きが −1 であるような絶対値関数が増え、x が大きいほど傾き
が 1 であるような絶対値関数が増えることを考えると、f (x) の各区間 [ai , ai+1 ] 内における 1 次関数の傾きは
単調に増加します（これは凸関数の和は凸関数ということから考えても良いです）。よって、これは凸関数で
あり、傾きが 0 であるような区間（実際には 1 点のみからなる区間になっている可能性もあります）を求め、
その区間内の点を 1 つ出力すれば良い、ということが分かります。
傾きが 0 であるような区間をどのようにして求めれば良いでしょうか？ここで、絶対値関数 |x − ai | にお
いて、傾きの変化点は x = ai であり、x = ai を “またいだ” 時に傾きが 2 だけ増えることに注目します。こ
のことは、複数の絶対値関数を足し合わせても変わることはありません。すなわち、関数 f (x) においても、

x = ai を “またいだ” 際、傾きは 2 だけ増加します（ただし、同じ絶対値関数が複数含まれる時、すなわち
ai = aj となる i, j が存在するような場合には、含まれる個数分だけ増加することに注意してください）。
そして、区間 [a0 = −∞, a1 ] において、f (x) の傾きは −N であるため、大雑把に言えば、 N
2 個の変化点を

“またぐ” と傾きが 0 となることが分かります。すなわち、昇順に並べた全ての変化点の内、ちょうど真ん中
にある変化点（N が偶数の場合には真ん中にある 2 つの変化点の間）において f (x) は傾きが 0 となり、最小
値を取ります。
この計算方法を実装する際には、変化点をソートした状態で格納してくれるデータ構造（以下セットと呼
ぶ）を 2 個用います（例えば C++ では multiset です）。片方のセットには昇順に並べた変化点の内、左半分
を、もう片方のセットには右半分を全て管理させます。この時、1 つ目のセットの最右点と 2 つ目のセットの
最左点の間の区間において f (x) は傾き 0 となります。
更新クエリ (ai , bi ) が来た際には、値 ai を 2 個、元と同じ条件（左半分を片方のセット、右半分をもう片方
のセット）を満たすよう適切にセットに挿入すれば良いです（変化点をあえて 2 個挿入することによって、
「1
つの変化点につき傾きが 1 変わる」と思うことが出来、シンプルになります）
。
さて、最小値を与える点は分かったので、具体的な最小値を求めます。これは、

• 新しく挿入された点が、元々最小値を与えた区間に含まれるならば 0
• 区間から外れているならば、区間の端点との距離（どちらか短い方）
を元の最小値に足したものになります。
以上から、更新・求値両方を高々定数回のセットの操作のみによって実現する事ができ、O(Q log Q) で問
題を解くことができます。また、凸性に基づいた値自体に対する三分探索や、Binary Indexed Tree を用いた

1

変化点の個数に関する二分探索を行う解法も存在します。

2


