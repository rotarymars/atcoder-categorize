書き換える操作は好きな順番で行っても構いません。なぜなら、同じカードに対して 2 回以上書き換える
のは無駄だからです。また、Ci に Bi 枚まで書き換える操作は、Ci に 1 個まで書き換える操作を Bi 回行え
ると考えます。各 Ci を Bi 個ずつ並べた列を D1 , D2 , ..., D∑ Bi とします。すると、操作は「選んだことの
ない i を選んで 1 枚まで Di に書き換える」と考えることができます。同じカードに対して 2 回以上書き換
えるのは無駄なので、この操作は合計で N 回しか行いません。したがって、Di の大きい方から N 個まで取
り出した列を新しい D として考えても構いません。

X 枚書き換えるとします。すると、書き換え元は小さい方から X 枚書き換えるのが最適です。書き換え先
は Di の大きいものから順に X 個選ぶのが最適です。X を 1 ずらすことによって書き換え元と書き換え先
はそれぞれ 1 つずつしか変化しないため、X を順に捜査することで O(M logM + N logN ) の計算時間で解
くことができます。
実 装 で は 、D の 大 き い 方 か ら N 個 ま で 取 り 出 す 部 分 が 難 し い か も し れ ま せ ん 。こ れ は 、

(B1 , C1 ), ..., (BM , CM ) を Ci の 大 き い 順 に ソ ー ト し て*1 配 列 D が N 未 満 で あ る 間 Ci を Bi 個 ま
で 1 個ずつ D に追加していく実装が楽でしょう。
最適な X を求めることもできます。A, D をソートして A1 ≤ A2 ≤ ... ≤ AN かつ D1 ≥ D2 ≥ ... ≥ D| D|
とします。すると、前述のアルゴリズムでは X を i − 1 から i にずらすことによって合計値は Di − Ai 変化
しますが、Di − Ai は単調非増加なので Di − Ai ≥ 0 すなわち Di ≥ Ai である間だけ操作を続けるのが最適
です。すなわち、そのような i の最大値 (なければ 0) を X とするのが最適です。

別解
残す整数と書き換え先とする整数を合計で N 個選んで N 個の整数の合計を最大化することを考えます。

(X1 , Y1 ), ..., (XN +M , YN +M ) を (1, A1 ), ..., (1, AN ), (B1 , C1 ), ..., (BM , CM ) とすると、問題は「整数 Yi を
Xi 個まで選ぶことができ、合計 N 個の整数を選ぶときその和の最大値を求めてください」となります。これ
は、Yi の大きい順に合計 N 個となるように選ぶのが最適です。この方法では O((N + M )log(N + M )) の
時間計算量で求めることができます。

*1 C++ 言語では (Ci , Bi ) の pair を降順にソートする実装が簡単です。より読みやすいコードを書きたいなら構造体を用いると良

いでしょう。

1

