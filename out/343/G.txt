
		公式
		
			
				G - Compress Strings 解説
			
			by yuto1115
			
		
		解説
		
		
			まず、\(S_i\) が \(S_j\) の部分文字列であるような \(i,j\) が存在する場合、「\(S_i\) を部分文字列として含む」という条件は「\(S_j\) を部分文字列として含む」という条件に完全に包含されているので、\(S_i\) の存在は抹消してしまって問題ありません。以下、そのような \(i,j\) が存在しないことを仮定します。

また、\(2\) つの文字列 \(X,Y\) について、\(X\) の末尾 \(k\) 文字と\(Y\) の先頭 \(k\) 文字が一致するような最大の \(k\) を \(f(X,Y)\) と表記します。

\(S_1,S_2,\dots,S_N\) 全てを部分文字列として含むような文字列のうち長さが最小となるものを \(1\) つ取り、この文字列の \(l_i\) 文字目から \(r_i-1\) 文字目までが \(S_i\) に対応するように \(l_i,r_i\) を \(1\) 組取ります。

一般性を失わず \(l_1 \leq l_2\leq \dots \leq l_N\) を仮定します。このとき、\(i=1,2,\dots,N-1\) 全てについて以下が成り立ちます。


\(l_i < l_{i+1} \leq r_i\)
\(r_i-l_{i+1}=f(S_i,S_{i+1})\)


これらが成り立たない場合、1 段落目で置いた仮定や 2 段落目で取った文字列の長さの最小性に矛盾します。

従って、\(S_1,S_2,\dots,S_N\) 全てを部分文字列として含むような文字列の長さの最小値を求める上では、以下のような文字列についてのみ考えても問題ありません。


\((1,2,\dots,N)\) のある順列 \((p_1,p_2,\dots,p_N)\) について、\(S_{p_1}\)、\(S_{p_2}\) の末尾 \(|S_{p_2}|-f(S_{p_1},S_{p_2})\) 文字、\(S_{p_3}\) の末尾 \(|S_{p_3}|-f(S_{p_2},S_{p_3})\) 文字、\(\dots\)、\(S_{p_N}\) の末尾 \(|S_{p_N}|-f(S_{p_{N-1}},S_{p_N})\) 文字をこの順に連結してできる文字列


よって本問題は、全ての \((1,2,\dots,N)\) の順列 \((p_1,p_2,\dots,p_N)\) に対する \(\displaystyle\sum_{i=1}^{N-1} f(S_{p_i},S_{p_{i+1}})\) の最小値を求める問題に帰着されます。

Z algorithm、KMP 法、rolling hash 等の文字列アルゴリズムを使って全ての \(i,j\) の組に対する \(f_(S_i,S_j)\) の値を予め求めておけば、上記の問題は巡回セールスマン問題と同様の bit DP によって解くことができます。

以上により、本問題を \(O(N\sum|S_i|+2^NN^2)\) などの計算量で解くことができました。

実装例 (C++) :



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
