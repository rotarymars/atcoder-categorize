
		公式
		
			
				G - Smaller Sum 解説
			
			by physics0523
			
		
		
		
		
			解説中では、 \(A_l, A_{l+1} , \dots A_r = A[l,r]\) と表現します。

以下のような merge-sort tree と呼ばれるデータ構造を用いるとこの問題に正解できます。

簡単のため、 \(N=2^{18} = 262144\) と固定しましょう。( 例えば、この問題では \(A_i (i > N)\) なる \(A_i\) について \(A_i = 2 \times 10^9\) としてしまえばよいです。 )


まず、 \(A[1,2^{18}]\) をソートした配列を持ちます。
この配列の子として、 \(A[1,2^{17}],A[2^{17}+1,2^{18}]\) をそれぞれソートした配列を持ちます。
これを再帰的に繰り返します。すなわち、 \(A[l,r]\) をソートした配列の子として、 \(A[l,(l+r-1)/2], A[(l+r+1)/2, r]\) をソートした配列を持ちます。


言葉で書くと複雑ですが、実際は segment tree と同じような構造でソートした配列を持ちます。構築時の時間 / 空間計算量は \(O(N \log N)\) です。

この時、各配列に対してそれらの累積和も保持することとすると、 segment tree に対するアクセスと同じ要領を使いながらアクセスした各配列に対して二分探索することで、 \(O(Q \log^2 N)\) でこの問題に正解できます。
また、確かにこのアルゴリズムはオンラインです。

実装例 (C++):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
