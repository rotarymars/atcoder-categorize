
		公式
		
			
				F - Numbered Checker 解説
			
			by physics0523
			
		
		
		
		
			この問題には様々な方針があります。但し実装量に大きな差があるので楽な方針を考えましょう。
サンプル \(1\) の \(6\) つ目の質問に着目します。
グリッドの各行ごとに考えてみましょう。グリッドは以下のようでした。



まず、各行ごとの和を求めます。各行ごとに非零な要素は公差 \(2\) の等差数列をなすので、等差数列の和の公式を用いて計算できます。
また、グリッドがチェッカー模様を成すことから、各行ごとの最も左の非零な要素は (存在するなら) 取り出された各行の \(1\) 要素目か \(2\) 要素目です。(最も右のものも同様です。)

次に、行ごとにまとめた後のことを検討します。まず奇数行目に着目しましょう。



奇数行目について以下が成り立ちます:
各行ごとの非零な要素の数を \(x\) とすると、行ごとの値の総和は公差 \(2 \times x \times M\) の等差数列になります。( \(x=0\) でも成り立ちます)
理由は、非零な要素がある列について、各列の値が公差 \(2 \times M\) の等差数列を成すからです。

以下のように、偶数行目についても同様です。



よって、 \(A_i\) 行目と \(A_i+1\) 行目の \(C_i\) 列目から \(D_i\) 列目に関する情報を計算した後、 \(A_i\) 行目から \(B_i\) 行目までの和を取るという方針がとれます。

実装上のポイントとして、等差数列の和を取る操作を何度も行うことになるので、このように何度も行う操作は関数として取り出して書いておくと実装の軽減に繋がります。

実装例(C++):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
