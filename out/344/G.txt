
		公式
		
			
				G - Points and Comparison 解説
			
			by physics0523
			
		
		
		
		
			\(x\) 軸を右方向、 \(y\) 軸を上方向にとるものとします。(通常の \(xy\) 平面と同様です)
このとき、問題は以下のように言い換えられます。


\(xy\) 平面上の \(N\) 点が与えられる。以下の \(Q\) 個の質問に対する答えを足し合わせよ。


\(xy\) 平面上の直線が与えられるので、その直線上またはその直線よりも上側に存在する点の数を求めよ。



各質問に対し、全ての点について \(Y \ge A \times X + B\) かどうかを判定するので、その質問の時点で点が \(- A \times X + Y\) に関してソートできていればよいです(これをソート S とします)。なので、これを実現することを考えます。

まず、質問の直線を \(A\) の昇順にソートすることを考えます。

\(A = -\infty\) である場合から始めることになりますが、この場合は単に \((X,Y)\) を辞書順にソートすればよいです。

ソート S 上でのある \(2\) 点 \((X_l,Y_l)\) と \((X_r,Y_r)\) の順序を考えましょう。


\(X_l = X_r\) である場合は常に \(Y_l < Y_r\) が保たれるように並びます。 (この \(2\) 点の順序が入れ替わることはありません。)

そうでない場合、これらを結ぶ直線の傾きを超えるタイミングでソート S 上での順序が反転します。


以上から、例えば以下の解法が成立します。


ソート S が成立するように点列を保持することを考える。
点列の隣接する \(2\) 点に関して、それらが今後傾きを増やしていくにあたって入れ替わるなら、入れ替わる傾きを記録しておき priority_queue で管理する。
実際に質問を処理していく。質問の処理の前に priority_queue を参照し、入れ替わっているべき \(2\) 点があるならそれがなくなるまで隣接点の swap を行う。
各質問は二分探索で処理する。


以上より、この問題に時間計算量 \(O(Q (\log Q + \log N) + N^2 \log N)\) で正解できます。

値を代入すると \(6.6 \times 10^8\) となりますが、実行時間制限が 10s であるため定数倍の悪い実装をしなければこの解法で AC を取ることができます。

実装例(C++):



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
