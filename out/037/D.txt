
f (i, j) := i 行 j 列からスタートする経路の総数 とする．求めたい答え
は，全てのマスに対する f (i, j) の和となる．この値は，f (i − 1, j), f (i +
1, j), f (i, j − 1), f (i, j + 1) のうち，その行き先のマスが存在していて，そ
こに移動できるマス の合計に 1 (このマスから始まり，移動せずに終了す
る経路に対応する) を加えたものである．
上の f (i, j) は，再帰的にコードを書くことで計算することができる．こ
のとき，無限に再帰が深くなることはない．なぜなら，移動先のマスに書
かれたは移動前のマスに書かれた値よりも大きく，これらの値の種類数は
最大でも H ∗ W 種類しかなく，これより多い回数大きくするということ
はできないからである．
しかし，このままでは非常に遅い．ここで，いつ計算しても f (i, j) の
値は不変であるので，一度この値を計算したら配列 (dp[i][j] とする) にこ
の答えを記憶しておき，二回目以降 f (i, j) が呼ばれた時はこの値を参照
してすぐ return をすることで，高速化をすることが可能である．全体で，
計算量は O(HW ) となる．この方法はメモ化再帰と呼ばれており，これ
は動的計画法の一種である．
またこの問題では入力サイズが大きいので，入力が遅い言語では高速
な入力を使うのが望ましい．例えば，C++では cin, cout ではなく scanf,
printf を使うべきである．

2


