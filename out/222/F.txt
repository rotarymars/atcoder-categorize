
		公式
		
			
				F - Expensive Expense 解説
			
			by  Nyaan
			
		
		
		
		
			この問題は次の 2 つの解き方があります。


直径 を利用した解き方
全方位木 DP を利用した解き方


の順に触れていきたいといきます。

1. 直径を利用した解き方

以下の説明ではグラフは木であるとします。また、無向グラフの頂点の組 \((s,t)\) に対して \(s\) と \(t\) の距離 (最短パスの長さ) を \(d(s,t)\) のように表します。

直径 とはグラフ内で最も離れている \(2\) 頂点の距離のことをいいます。形式的には、グラフの頂点の組 \((s,t)\) に対する \(d(s,t)\) の最大値とも言えます。

最短距離が直径と一致する頂点の組を \((s,t)\) とします。このときグラフ内の全ての頂点に対して以下の性質が成り立ちます。


すべてのグラフ内の頂点 \(u\) に対して、 \(u\) から最も遠い頂点のうちの 1 つは \(s\) か \(t\) である。言い換えると、
\[\max_{v \in G} d(u,v) = \max(d(u,s), d(u,t))\]が成り立つ。


この問題は直径の性質を利用して次のように解くことができます。

与えられたグラフを \(G(V,E)\) のように置きます。( \(V\) は頂点集合、 \(E\) は辺集合です。)
すべての頂点 \(v \in V\) に対して、補助的なノード \(v'\) を新たに置き、 \(v\) と \(v'\) の間に重み \(D_v\) の辺を貼った拡張グラフを新たに考えます。

以下の図は サンプル1 の拡張グラフを図示したものです。



求めるものはすべての \(v \in V\) に対して、
\[\max_{u \in V, u \neq v} d(v,u') \ \cdots (\ast)\]となりますが、これは拡張グラフの直径を計算して \(d(s',t')\) が直径と一致する補助的なノードの組を \(s',t'\) としたときに
\[
(\ast) = 
\begin{cases}
d(v, t') & v = s \\
d(v, s') & v = t \\
\max(d(v,s'),d(v,t')) & \mathrm{otherwise} 
\end{cases}
\]であることが、直径の証明と同様の方法で証明できます。

直径はダイクストラ法を \(2\) 回適用すれば計算できます。以上よりこの問題を \(\mathrm{O}(N \log N)\) で解くことができました。


追記：グラフは木なので BFS/DFS でも直径を求めることができます。よってこの問題を \(\mathrm{O}(N)\) で解くことができました。


C++ による想定解は次の通りです。





2. 全方位木 DP を利用した解き方

この問題は 全方位木 DP (Rerooting) と呼ばれるアルゴリズムでも解くことができます。

全方位木 DP の解説は ei13333 氏による記事(日本語) が非常に有名で、全方位木 DP がどのようなアルゴリズムかを知らない人はこちらを読むことをお勧めします。

ここではアルゴリズムを簡潔に述べます。まず、 与えられたグラフを頂点 \(1\) を根とする根付き木とみなします。 \(m_i\) を


\(m_i:=\) \(i\) から \(i\) の子孫 (\(i\) 自身を含まない) へ旅行したときの旅費の最大


と定義すると、これは次に書く DP で計算できます。



次に前計算を利用して Rerooting を行い、


\(dp_i ;=\) \(i\) に対する求める答え


を計算します。



2回目の DFS は上記の通りに実装すると \(\mathrm{O}(N^2)\) かかってしまいますが、累積和などのデータ構造を利用すれば 計算量を \(\mathrm{O}(N)\) に落とすことができます。よってこの問題を \(\mathrm{O}(N)\) で解くことができました。

解答例では全方位木 DP を抽象化した実装を行いました。競技プログラミングにおける “抽象化” とは、関数や変数を与えるとアルゴリズムが動作するようなライブラリを作成することで、コンテストの際にアルゴリズムの部分をブラックボックス化して実装できるようにすることを言います。

抽象化のモチベーションとしては、ライブラリを使用してコンテスト中の実装を省略することでより素早く AC を取りたい、というものが主だったものとして挙げられます。たとえば全方位木 DP を利用する問題を例に挙げると、ほとんどの場合は


DP テーブルに載せる値の型
頂点同士をマージする関数およびその単位元
親に値を返す関数
子に頂点が存在しないときの値 (この問題では単位元と一致)


の 4 つが問題によって異なり、それ以外は問題によらず同じ実装をすれば問題を解くことができます。そこで、上記の 4 つを与えると自動的に全方位木 DP を計算して計算結果を返してくれるようなライブラリを持っていると確かに高速に AC を取ることができます。

競技プログラミングにおける抽象化の例としては AtCoder Library の Segment Tree などが挙げられます。ドキュメント に詳しい使い方が書かれているので、アルゴリズムを抽象化する例として読んでみるとよいでしょう。

とはいえ、 AtCoder では多大な実装を要求する問題はほとんど存在しないため、ライブラリの作成がレートにもたらす寄与は大きくありません。また、抽象化ライブラリの作成はコンテストで問題を解くよりも得てして大変なことが多いです。

以上の理由から競技プログラミングの勉強法としては不向きかもしれませんが、アルゴリズムやプログラミング言語に対する理解を深める方法の 1 つとしてはありだと個人的に思っています。

C++ による抽象化全方位木 DP の実装例、およびこの問題の解答例は次の通りです。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
