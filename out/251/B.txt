
		公式
		
			
				B - At Most 3 (Judge ver.) 解説
			
			by  Nyaan
			
		
		
		
		
			まず、この問題文をプログラミング的な手続きに言い換えると次のような問題になります。この手順を十分高速に計算できればこの問題を解くことができます。


\(1\) 以上 \(W\) 以下のすべての整数について「\(n\) はよい整数か」を管理するフラグ用の配列 flag を用意する。flag ははじめ false で初期化されている。
\(3\) 個以下であるおもりの集合全てを調べる。各集合についておもりの重さの和 \(w\) を求める。そして、\(w\) が \(W\) 以下ならば flag[w] を true にする。
最終的に true であるフラグの個数が答えとなる。


上の手順の中で一番難しいのが「 \(3\) 個以下であるおもりの集合全てを調べる」という部分で、ここで探索の方法を間違えると計算量が膨大になって TLE しています。
この部分は「\(3\) 個以下である」を「\(1\) 個 または \(2\) 個または \(3\) 個である」と言い換えるのがポイントです。「おもりの個数がちょうど \(x\) 個である集合」の場合は 以下のような for-loop を用いた実装で \(\mathrm{O}(N^x)\) で計算することができるので、このように言い換えたあと \(1\) 個の場合, \(2\) 個の場合, \(3\) 個の場合を別々に計算すれば、この問題は for-loop で実装できる問題に帰着します。



計算量はフラグ用配列の分の \(\mathrm{O}(W)\) と for-loop の \(\mathrm{O}(N+N^2+N^3) = \mathrm{O}(N^3)\) を合わせて \(\mathrm{O}(W + N^3)\) となり、これは十分高速に動作します。

C++ による実装例は次の通りです。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
