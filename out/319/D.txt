
		公式
		
			
				D - Minimum Width 解説
			
			by MMNMM
			
		
		
		
		
			次の問題について考えてみましょう。


高橋くんが文章を幅 \(W\) のウィンドウに表示しようとしたとき、最低でも何行必要ですか？ただし、\(L _ i\leq W\) です。


単語を先頭から貪欲に（改行する必要がなければ改行せずに）配置するのが最適です。

証明

ある単語で改行する必要がないのに改行した最適解があるとします。
その単語以降を \(k\) 行以内に収めることができる場合、その単語で改行しなくても \(k\) 行以内に収めることができます。

よって、改行する必要がないところで改行をしない最適解があることが示されました。



よって、この問題は \(O(N)\) 時間で解くことができます。

この問題の答えを \(f(W)\) とすると、\(f(W)\leq M\) であるような最小の \(W\) が元の問題の答えです。

\(f\!\left(-1+\sum _ i(1+L _ i)\right)=1\) なので、答えは\(\max _ iL _ i\) 以上 \(-1+\sum _ i(1+L _ i)\) 以下です。

\(f(W)\) は単調減少する関数なので、二分探索でこの問題を解くことができました。

時間計算量は \(O(N\log\sum L _ i)\) になります。

実装例は以下のようになります。
実装の際は、すべての単語の先頭にあらかじめ空白をつけておき、単語の間に間隔を開ける必要がないようにしておくとシンプルになるかもしれません（この場合、答えが \(1\) ずれることに注意してください）。



C++20 以降では、std::ranges::partition_point 関数に ranges::iota_view と判定関数を渡すことで二分探索を行うことができます。
この関数を用いる際、判定関数は先頭から true → false の順番になっている必要があります。



		
		
			
				投稿日時:
				
				
			
				
				最終更新:
				
				
			
			
		
	
