まず、問題で与えられるスコアの正負を逆にして、ゲームの最終的なスコアを最⼩化すると
考えてみます。そうすると、この問題は、スコアを距離とみなした頂点１から頂点 N への

最短経路問題とみなすことができます。最短経路問題を解くための有名なアルゴリズムに
は、ダイクストラ法、ベルマンフォード法、ワーシャルフロイド法が存在します。今回の問
題では、負のコストの辺が存在するため、ダイクストラ法を適⽤できません。また、ワーシ
ャルフロイド法の時間計算量は O(N^3)であるため厳しいです(C++なら通る可能性があり
ます)。そこで、時間計算量 O(NM)であるベルマンフォード法をもとに解法を考えていき
ます。
ここで、最短距離を表す⻑さ N の配列 dist を⽤意して、最短距離の１回の更新を次のよう
に定義します。
全ての辺に注⽬して、頂点 a1 の最短距離(dist[ai])とコスト ci から頂点 bi の最短距離
(dist[bi])を更新する。
負閉路(辺のコストの総和が負となる閉路)がない場合には、最短距離の更新を N-1 回繰り
返すことで最短経路を求めることができます。なぜなら、この最短経路において各頂点は
⾼々１回しか登場しないからです(２回以上登場したら閉路ができる)。次に、負閉路の検出
について考えてみます。N 回⽬以降の更新でも最短距離をより短くできれば、その経路上に
は同じ頂点が２回以上登場しているので閉路があると⾔えます。そして、閉路の存在と最短
距離を更新できたことから、負閉路があると⾔えます。
これらの事実を利⽤して、次のような解法が考えられます。
1. 頂点１の最短距離を dist[1]=0、その他の頂点 v の最短距離を dist[v]=∞と初期化しま
す
2. 最短距離の更新を N-1 回繰り返します(経路の⻑さは最⼤で N-1 であるため)
3. 頂点 N の最短距離を表す変数として ans=dist[N]とします
4. 次に、負閉路を検出するための⻑さ N の配列 negative を⽤意して、false で初期化しま
す
5. 最短距離の更新を N 回繰り返す(負閉路の⻑さは最⼤で N であるため)。ただし、この
とき更新された頂点 bi について、negative[bi]=true とします。また、negative[ai]が true
の場合には、negative[bi]を true にします
そして、negative[N]が true になっている場合には「inf]、そうでない場合には-ans を出⼒
します。この問題の場合には∞> -N min ci となるように設定すれば⼗分です。この解法の
時間計算量は O(NM)となり、⼗分間に合います。


